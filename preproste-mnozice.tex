\chapter{Preproste množice}
\label{cha:preproste-mnozice}


Temeljni gradniki sodobne matematike so \df{množice}, ki so skupki ali zbirke matematičnih
objektov, lahko spet množice. Vsaka množica sestoji iz \df{elementov} in je z njimi
natančno določena. Kadar je $a$ element množice $M$, to zapišemo kot $a \in M$.

Ideja množice kot poljubne zbirke elementov je zavajajoče preprosta, kar so na lastni koži
izkusili matematiki na prelomu iz 19.~v 20.~stoletje. Takrat so že vedeli, da so množice zelo
uporabne in da lahko iz njih tvorimo razne vrste matematičnih objektov. A znameniti
matematik in filozof Bertrand Russell je odkril paradoks, ki se imenuje po njem, in gre
takole. Naj bo~$R$ množica vseh množic, ki niso element same sebe. Ali $R$ je element~$R$?
Če je $R$ element $R$, potem iz definicije $R$ sledi, da $R$ ni element $R$. In če $R$ ni
element $R$, spet iz definicije $R$ sledi, da $R$ je element $R$. Torej $R$ hkrati je in
ni svoj element, kar je protislovje! Russellov paradoks ste morda že spoznali v
priljubljeni različici, ki govori o vaškem brivcu, ki brije vse vaščane, ki ne brijejo
samih sebe.

Russellov paradoks je povzročil pravo krizo v temeljih matematike. Ker so bile množice
nepogrešljivo orodje, jih niso hoteli kar zavreči, po drugi strani pa je bilo treba
preprečiti Russellov in druge paradokse, ki so jih še odkrili. Bertrand Russell je
predlagal rešitev, ki jo je poimenoval \df{teorija tipov}. Russellova teorija tipov je
pomembno vplivala na nadaljni razvoj temeljev matematike, sodobna teorija tipov pa je
pomembno orodje v računalništvu. Tako kot množice so bili tipi skupki elementov, a so
tvorili neskončno hierarhijo, v kateri so bili elementi tipa vedno iz nižjega nivoja
hierarhije kot tip, ki so mu pripadali. Za potrebe večine matematike zadostuje že
preprostejša dvoslojna hierarhija množic in \df{razredov}. Množice smejo biti elementi
množic in razredov, razredi pa ne. Russellov paradoks izgine, ker je $R$ razred vseh
tistih množic, ki niso same svoj element. Vprašanje, ali je $R$ element samega sebe, tako
postane nesmiselno, saj $R$ ni množica. A zaenkrat odložimo podrobnejšo obravnavo razredov
in se raje posvetimo osnovnima pojmoma, množica in preslikava.

V splošni razpravi o množicah, ki bi presegala meje matematične vede, bi se opirali na
zgodovinski in družbeni kontekst, jezikovni izvor in rabo besed `množica', `skupek' in
`zbirka', kognitivno analizo, eksperimente, filozofijo itn. Vsi ti vidiki so za matematike
izjemo koristni, saj iz takih ``pred-matematičnih'' obravnav črpamo sveže zamisli in
matematiko naredimo zares uporabno. Ko pa delujemo znotraj matematike, zunanje vplive
odmislimo in se zanašamo le še na pravila logičnega sklepanja in matematične zakone, da ne
prihaja do nejasnosti in dvomljivih sklepov.

Kot matematiki lahko ustvarimo takšen ali drugačen pojem množice in pri tem imamo popolno
svobodo. Se množica lahko spreminja ali vedno vsebuje iste elemente? Je pomemben vrsti red
elementov v množici? Sme množica biti element same sebe? Ali morajo biti elementi množice
izračunljivi? To so vprašanja, ki nimajo enoznačnega odgovora. In res je znanih več med
seboj nezdružljivih zvrsti teorije množic, ki matematično opredeljujejo različne vidike
običajnega razumevanja besede `množica'. Mi bomo spoznali ``standardno'' teorijo množic,
ki jo uporablja velika večina matematikov.


\section{Načelo ekstenzionalnosti}
\label{sec:nacelo-ekstenzionalnosti}

Zamisel, da je množica natančno določena s svojimi elementi, izrazimo z matematičnim
zakonom, ki mu pravimo \df{načelo ekstenzionalnosti}:

\begin{pravilo}[Ekstenzionalnost množic]
  Množici sta enaki, če vsebujeta iste elemente.
\end{pravilo}

Kaj pravzaprav pomeni, da je to ``pravilo'', ``matematični zakon'' ali ``načelo''? So ga
razglasili v parlementu, je to zakon narave, ali morda dogma, ki jo je razglasil profesor
na predavanjih? Bodo tisti, ki načela ekstenzionalnosti ne spoštujejo, deležni Lešnikove
masti? Ne. Matematični zakoni so \emph{dogovori}, nekakšna pravila matematične igre. V
zgodovinskem razvoju matematike so se uveljavili tisti dogovori, ki so bili uporabni v
naravoslovju in tehniki, ali pa so v njih matematiki videli notranjo lepoto in lastno
uporabno vrednost.

Pravkar smo se dogovorili, da bomo obravnavali matematične objekte množice, ki vsebujejo
elemente in da zanje velja načelo ekstenzionalnosti. Namesto besed `množica' in `element'
bi lahko izbrali tudi kaki drugi besedi, denimo `zbor' in `član', ali celo `morje' in
`riba', s čimer se matematična vsebina pojmov ne bi čisto nič spremenila, čeprav ne gre
preveč izzivati svojih stanovskih kolegic in kolegov. Strukturo, lastnosti in povezave med
matematičnimi objekti namreč določajo dogovorjeni matematični zakoni in ne besede, s
katerimi jih poimenujemo.

Še enkrat poudarimo, da ima vsakdo, še posebej pa mladi um, popolno svobodo matematičnega
ustvarjanja. Želite razmišljati o drugačnih množicah, ki ne zadoščajo načelou
ekstenzionalnsti? Ali pa o številih, ki zadoščajo zakonu $x + x = 0$? O geometriji, v
kateri skozi točko lahko potegnemo dve vzporednici k dani premici? Kar dajte! Pri tem vas
le prosimo, celo zahtevamo, da razmišljate temeljito, vztrajno in globoko, da ste iskreni
do sebe in ostalih ter da svoje zamisli in spoznanja predstavite na matematikom razumljiv
način.

Vrnimo se k našim množicam. Načelo ekstenzionalnosti nam pove, da lahko množico podamo
tako, da natančno opredelimo njene elemente. A to ne pomeni, da množica obstaja, brž ko jo
lahko natančno opredelimo! To je pot, ki vodi naravnost do Russelovega paradoksa, saj so
elementi paradoksalne množice~$R$ natančno opredeljeni. Potrebujemo dodatna pravila, ki
določajo dopustne \df{konstrukcije množic}. Izbrati jih moramo previdno, da se izognemo
težavam.

\section{Končne množice}
\label{sec:koncne-mnozice}

Posebej preprosta konstrukcija množic združi končen nabor matematičnih objektov v množico.
Na primer, če so $a$, $b$ in $c$ matematični objekti, potem lahko tvorimo množico
%
\begin{equation*}
  \set{a, b, c}
\end{equation*}
%
katere objekti so natanko $a$, $b$ in $c$. To pomeni, da za vsak matematični objekt~$x$
velja
%
\begin{equation*}
  \text{$x \in \set{a, b, c}$, če in samo če $x = a$ ali $x = b$ ali $x = c$.}
\end{equation*}
%
Fraza ``če in samo če'' tu pomeni, da velja dvoje:
%
\begin{enumerate}
\item Če $x = a$ ali $x = b$ ali $x = c$, potem $x \in \set{a, b, c}$.
\item Če $x \in \set{a, b, c}$, potem $x = a$ ali $x = b$ ali $x = c$.
\end{enumerate}
%
Tako nam na primer prva trditev zagotavlja $1+1 \in \set{1, 2, 4}$, ker velja
vsaj ena od možnosti: $1 + 1 = 1$ ali $1 + 1 = 2$ ali $1 + 1 = 3$. Iz druge trditve sledi, da
$5 \in \set{1, 2, 3}$ ne velja, ker ne velja nobena od možnosti: $5 = 1$ ali $5 = 2$ ali
$5 = 3$.

Splošna konstrukcija končnih množic poteka takole.

\begin{pravilo}
  \label{pravilo:koncna-mnozica}
  Za vse objekte $a$, $b$, \dots, $z$ je $\set{a, b, \ldots, z}$ množica, katere elementi
  so natanko objekti $a$, $b$, \dots, $z$.
\end{pravilo}

Za trenutek ustavimo tok misli in opozorimo, da zapis s tropičjem `$\ldots$' ni dovolj
natančen, saj dopušča dvoumnosti. Denimo, so elementi množice
%
\begin{equation*}
  \set{3, 5, 7, \ldots, 31},
\end{equation*}
%
liha števila med $3$ in $31$, ali samo praštevila? Zapis res ni dovolj natančen. Kljub
temu tak zapis v praksi uporabljamo, ker v praksi bralec večinoma pravilno ugane, kaj je
bilo mišljeno, saj imamo ljudje zelo podobne sposobnosti prepoznavanja vzorcev. Z
matematičnega vidika pa to ni dopustno, saj lahko tropičje \emph{vedno} razumemo na več
načinov. (Ne verjamete? Naslednji člen v zaporedju $1, 2, 3, \ldots$ je seveda~$5$, ker je
naslednji člen vsota prejšnjih dveh, kot v Fibonaccijevem zaporedju.)

Kot smo že omenili, želimo pojem množice, pri kateri vrstni red elementov ni pomemben.
Torej bi morali biti množici $\set{1, 2}$ in $\set{2, 1}$ enaki. Pa je to res? Velja ena
od treh možnosti:
%
\begin{enumerate}
\item Iz načela ekstenzionalnosti in konstrukcije množic $\set{1, 2}$ in $\set{2, 1}$ sledi, da sta enaki.
\item Iz načela ekstenzionalnosti in konstrukcije množic $\set{1, 2}$ in $\set{2, 1}$ sledi, da nista enaki.
\item Načelo ekstenzionalnosti in konstrukcije množic $\set{1, 2}$ in $\set{2, 1}$ ne določajo, ali sta enaki.
\end{enumerate}
%
V prvem primeru bi želeli dokazati enakost. V drugem primeru smo v zagati, saj smo se
dogovorili za matematična pravila, ki imajo neželene posledice. V tretjem primeru moramo
dodati še kakšne nove zakone o množicah. Na srečo obvelja prva možnost.

\begin{trditev}
  Množici $\set{1, 2}$ in $\set{2, 1}$ sta enaki.
\end{trditev}

\begin{proof}
  Dokaz, ki ga bomo zapisali je izjemno podroben in ga v praksi matematik ne bi zapisal,
  saj je z njegovim branjem več dela, kot če bi naredili sami. Ker pa želimo pokazati, da
  tudi najbolj trivialna dejstva lahko dokažemo, ga zapišimo.

  Izhajati smemo izključno iz naslednji dejstev:
  %
  \begin{itemize}
  \item načelo ekstenzionalnosti,
  \item $x \in \set{1, 2}$, če in samo če $x = 1$ ali $x = 2$,
  \item $x \in \set{2, 1}$, če in samo če $x = 2$ ali $x = 1$.
  \end{itemize}
  %
  Najprej uporabimo načelo ekstenzionalnosti, ki zagotavlja, da sta $\set{1, 2}$ in
  $\set{2, 1}$ enaki, če imata iste elemente. Dokažimo torej, da imata iste elemente. To
  naredimo v dveh korakih:
  %
  \begin{enumerate}
  \item Dokažimo, da za vsak element $\set{1, 2}$ dokažemo, da je element $\set{2, 1}$.
    Naj bo $x \in \set{1, 2}$. Iz definicije množice $\set{1, 2}$
    sledi, da je $x = 1$ ali $x = 2$. Obravnavamo dva podprimera:
    %
    \begin{enumerate}
    \item Primer $x = 1$: iz $x = 1$ sledi, da je $x = 2$ ali $x = 1$, zato je $x \in \set{2, 1}$.
    \item Primer $x = 2$: iz $x = 2$ sledi, da je $x = 2$ ali $x = 1$, zato je $x \in \set{2, 1}$.
    \end{enumerate}
    %
  \item Dokažimo, da za vsak element $\set{2, 1}$ dokažemo, da je element $\set{1, 2}$.

    Ta korak je povsem podoben prvemu, le da je treba povsod zamenjati~$1$ in~$2$.
    Matematik bi zato na tem mestu zapisal, da je drugi korak podoben prevemu in dokaz
    zaključil. A tega tokrat ne bomo storili in bomo zapisali popoln dokaz.

    Naj bo $x \in \set{2, 1}$. Iz definicije množice $\set{2, 1}$ sledi, da je $x = 2$ ali
    $x = 1$. Obravnavamo dva primera:
    %
    \begin{enumerate}
    \item Primer $x = 2$: iz $x = 2$ sledi, da je $x = 1$ ali $x = 2$, zato je $x \in \set{1, 2}$.
    \item Primer $x = 1$: iz $x = 1$ sledi, da je $x = 1$ ali $x = 2$, zato je $x \in \set{1, 2}$. \qedhere
    \end{enumerate}
    %
  \end{enumerate}
\end{proof}

Mimogrede, črn kvadratek označuje konec dokaza. Imenuje se tudi ``Halmos'' po matematiku
Paulu Halmosu, ki ga je prvi uporabljal. S podobnim razmislekom, ki ga prepuščamo za vajo,
lahko dokažemo, da ni pomembno, ali se element pojavi enkrat ali večkrat.

\begin{naloga}
  Podrobno dokažite, da sta množici $\set{1, 1, 2}$ in $\set{1, 2}$ enaki.
\end{naloga}

V prejšnji nalogi smo zapisali $\set{1, 1, 2}$. Pa je to sploh dovoljeno?
Pravilo~\ref{pravilo:koncna-mnozica} pravi, da lahko iz objektov $a, b, c, \ldots, z$
tvorimo končno množico $\set{a, b, \ldots, z}$. Nikjer ne piše, da smeta biti $a$ in $b$
enaka, zato je upravičeno vprašanje, ali je dovoljeno za $a$ in $b$ vzeti~$1$. V
matematiki vse razumemo dobesedno. V pravilu~\ref{pravilo:koncna-mnozica} piše ``Za vse
objekte'', torej imamo povsem proste roke. Povedano z drugimi besedami, množico
$\set{1, 1, 2}$ smemo tvoriti, ker nikjer ne piše, da morajo biti elementi različni.

V zvezi s pravilom~\ref{pravilo:koncna-mnozica} se pojavljajo še drugi dvomi. Ali smemo
tvoriti množico, ki ima več elementov, kot je črk abecede? Ali bi bilo pravilo še vedno
isto, če bi namesto ``$a, b, \ldots, z$'' zapisali ``$a, b, \ldots, j$''? Ali smemo
tvoriti množico z nič elementi? Če namreč vstavimo nič elementov, se pravilo glasi ``Za
vse objekte je $\set{\,}$ množica, katere elementi so natanko objekti,'' kar je vsaj
nenavadno. Iz nesrečnega tropičja se res ne vidi, kaj je in kaj ni dovoljeno. Če poškilite
v razdelek~\ref{sec:aksiomi-teorije-mnozic}, kjer so našteti ``uradni'' aksiomih teorije
množic, tam pravila o končnih množicah ne boste našli, saj sledi iz treh bolj osnovnih
pravil.

\begin{pravilo}
  \label{pravilo:prazna-mnozica}
  \df{Prazna množica} $\emptyset$ je množica, ki nima elementov.
\end{pravilo}

\begin{pravilo}
  \label{pravilo:neurejeni-dvojec}
  Za vsak $x$ in $y$ je \df{(neurejeni) par} ali \df{dvojec} $\set{x, y}$ množica, katere
  elementa sta natanko $x$ in $y$.
\end{pravilo}

\begin{pravilo}
  \label{pravilo:unija}
  Za vsaki množici $A$ in $B$ je \df{unija $A \cup B$} množica, ki ima za elemente
  natanko vse objekte, ki so element $A$ ali element $B$.
\end{pravilo}

V pravilu~\ref{pravilo:neurejeni-dvojec} smo besedo ``neurejeni'' zapisali v oklepaju, kar
pomeni, da beseda pravzaprav ni pombembna in bi jo lahko tudi izpustili. Se pravi, da
``neurejeni dvojec'' in ``dvojec'' pomenita isto. V primeru nejasnosti raje uporabimo
daljšo obliko.

Tri nova pravila skupaj nadomestijo pravilo~\ref{pravilo:koncna-mnozica} in odstranijo
marsikateri dvom o uporabi. Prvo pravilo pojasni, da lahko tvorimo množico brez elementov.
Poleg oznake $\emptyset$ je za prazno množico smiselno uporabiti tudi zapis $\set{\,}$.

Drugo pravilo pove, kako lahko tvorimo množico z dvema elementoma, pa tudi z enim.
Spomnimo se, pravila je treba brati dobesedno: za $x$ in $y$ bi lahko vzeli dvakrat isti
objekt~$z$ in tvorili množico $\set{z, z}$, ki ima natanko elementa $z$ in $z$. To je
pravzaprav množica z enim samim elementom $z$, zato ji pravimo tudi \df{enojec} in jo
zapišemo~$\set{z}$.

Tretje pravilo nam omogoča, da tvorimo večje množice. Denimo, množico z elementi $a$, $b$,
$c$ lahko tvorimo kot unijo
%
\begin{equation*}
  \set{a, b} \cup \set{c}.
\end{equation*}
%
To ni edini način, enako množico lahko dobimo na več načinov:
%
\begin{equation*}
  (\set{a} \cup \set{b}) \cup \set{c}
  \quad\text{ali}\quad
  \set{b} \cup \set{c, a}
  \quad\text{ali}\quad
  \set{a,c,a} \cup \set{b,c}
  \quad\text{itn.}
\end{equation*}
%
Seveda bi morali dokazati, da so vse te množice enake, a tega ne bomo storili.

Pogosto nam bo prišlo prav, da bomo imeli pri roki množico z enim elementom, pri čemer nam
bo vseeno, kaj ta element je. V ta namen postavimo pravilo, ki zagotavlja obstoj množice z
enim elementom.

\begin{pravilo}
  \label{pravilo:enojec}
  \df{Standardni enojec} je množica~$\one$, katere edini element je~$\unit$.
\end{pravilo}

Morda se zdi nenavadno, da množico označimo s številom, a ta občutek bo hitro izginil, ko
bomo računali z množicami. Pravaprav bi lahko prazno množico označili z nič $\mathbf{0}$,
in nekateri matematiki to dejansko počnejo.

Edini element množice $\one$ smo označili z nenavadnim zapisom $\unit$. Na tem mestu ne
bomo pojasnili, zakaj pišemo tako, radovedneži pa lahko pogledajo v
razdelek~\ref{sec:aritmetika-tarskega}. Mimogrede, seveda velja $\one = \set{\unit}$.

Pravilo~\ref{pravilo:enojec} ni nujno potrebno, saj lahko tvorimo veliko različnih enojcev
kar sami $\set{\emptyset}$, $\set{42}$, $\set{\set{\emptyset}}$ itn. Ali je kateri od njih
``prvi med enakimi'' in bi ga lahko uporabljali kot ``standardni'' enojec? Ker je odgovor
v veliki meri stvar osebnega mnenja, je bolje, da razglasimo pravilo, ki ustoliči
standardni enojec. S prazno množico nimamo podobnih težav, saj je ena sama.

% \subsection{Druge množice}

% \andrej{To ne paše sem, ker bi bilo tu dosti bolj naravno nadaljevati s preslikavami.
%  To bomo prestavili na mesto, kjer bo dejansko prišlo prav.}

% Množice, s katerimi v matematiki delamo, tipično vsebujejo števila, ali pa so vsaj na tak ali drugačen način izpeljane iz številskih množic. Spomnimo se standardnih oznak najpogosteje uporabljanih številskih množic.
% \begin{center}
% \begin{tabular}{|cc|}
% \hline
% \textbf{Množica} & \textbf{Oznaka} \\
% \hline
% množica naravnih števil & $\NN$ \\
% množica celih števil & $\ZZ$ \\
% množica racionalnih števil & $\QQ$ \\
% množica realnih števil & $\RR$ \\
% množica kompleksnih števil & $\CC$ \\
% \hline
% \end{tabular}
% \end{center}

% Nekateri $0$ vzamejo za naravno število, nekateri ne. To je v celoti stvar dogovora, kaj pomeni pojem ``naravno število''. Za nas bo prišlo bolj prav, če ničlo štejemo kot element množice naravnih števil, torej $\NN = \set{0, 1, 2, 3, \ldots}$.

\section{Preslikave}

Temelj matematike ne tvorijo le množice, ampak tudi drugi matematični pojmi. Prvi izmed
njih je \df{preslikava}, oziroma s tujko \df{funkcija}.\footnote{Nekateri uporabljajo
  izraz ``funkcija'' samo za tiste preslikave, ki slikajo v realna ali kompleksna števila,
  vendar to navado izpodriva računalništvo, saj funkcije v programskih jezikih nimajo
  omejitev. Dandanes večina matematikov besedo ``funkcija'' obravnava kot sopomenko besede
  ``preslikava'' in tako jo bomo uporabljali tudi mi.} V srednji šoli ste že spoznali
nekatere preslikave, kot so na primer linearne preslikave, trigonometrijske funkcije,
logaritem itd. Nas pa ne bodo zanimale posamezne preslikave, ali posebne lastnosti
preslikav, ampak preslikave na splošno.

Vsaka preslikava ima tri sestavne dele: \df{domeno} ali \df{začetno množico},
\df{kodomeno} ali \df{ciljno množico} in \df{predpis}. Domeni se pogosto reče tudi
\df{definicijsko območje}. Če govorimo o preslikavi, ki ima domeno~$X$ in kodomeno~$Y$, to
ponazorimo s puščico med $X$ in $Y$, takole
%
\begin{equation*}
  \xymatrix{
    {X} \ar[r] &
    {Y}
  }
\end{equation*}
%
Če želimo preslikavo poimenovati, na primer $f$, zapišemo
%
\begin{equation*}
  \xymatrix{
   {f : X} \ar[r] &
    {Y}
  }
  \qquad\text{ali}\qquad
  \xymatrix{
   {X} \ar[r]^{f} &
   {Y}
  }
\end{equation*}
%
Pravimo, da je \df{$f$ preslikava iz $X$ v $Y$}. Zapis nad puščico je prikladen, kadar
imamo opravka z večimi preslikavami, ki jih predstavimo z diagramom. Na primer,
%
\begin{equation*}
  \xymatrix{
    {X} \ar[r] &
    {Y} \ar[r]^{f} &
    {Z}  &
    {W} \ar[l]_{g}
  }
\end{equation*}
%
nam pove, da imamo opravka z (neimenovano) preslikavo iz $X$ v $Y$, s preslikavo $f$ iz
$Y$ v $Z$ in s preslikavo $g$ is $W$ v $Z$. Diagrami so lahko še precej bolj zapleteni.

Tretji del preslikave je predpis, ki določa, kako elemente domene preslikamo v elemente
kodomene. Kaj pravzaprav to pomeni? Možnih je več odgovorov. V srednji šoli predpis
enačimo z matematično formulo, ki spremenljivko preslika v vrednost, na primer $x$ slika v
$2 \sin(x + \pi/4)$. S simboli to zapišemo
%
\begin{equation*}
  x \mapsto 2 \sin(x + \pi/4).
\end{equation*}
%
in preberemo ``$x$ se slika v dvakrat sinus od $x$ plus pi četrtin.''
%
Matematiki smo natančni, zato ne mešamo uporabe puščic $\to$ in $\mapsto$. Navadna puščica
se uporablja pri oznaki domene in kodomene, repata pa v predpisu. V računalništvu besedo
`predpis' razumemo kot `programska koda' in o preslikavah razmišljajo kar kot o
algoritmih --- tudi to je eden od možnih pogledov na preslikave.

V teoriji množic razumemo besedo `predpis' kot kakršnokoli prirejanje med elementi množic
domene~$X$ in kodomene~$Y$, mora pa veljati:
%
\begin{itemize}
\item \df{celovitost}: vsakemu elementu iz $X$ je prirejen vsaj en element iz $Y$,
\item \df{enoličnost}: če sta elementu $x$ prirejena $y \in Y$ in $z \in Y$, potem $y = z$.
\end{itemize}


\subsection{Funkcijski predpisi}
\label{sec:funkcijski-predpisi}

Predpise lahko podamo na različne načine, najbolj pogost pa je \df{funkcijski predpis}, ki
se mu še posebej posvetimo in se ob njem naučimo nekaj natančnosti. Funkcijski predpis ima
obliko
%
\begin{equation*}
  x \mapsto \cdots,
\end{equation*}
%
ki smo jo že videli maloprej. Na desni, lahko namesto $\cdots$ zapišemo izraz, v katerem
se sme pojaviti simbol~$x$, denimo
%
\begin{equation*}
  x \mapsto 1 + x^2.
\end{equation*}
%
Ni nujno, da se~$x$ pojavi, denimo $x \mapsto 42$ vsakemu elementu iz domene priredi
število $42$. V funkcijskem predpisu se smejo pojaviti tudi drugi simboli, ki jim
pravimo \df{parametri}. Tako je
%
\begin{equation*}
  x \mapsto a \cdot x + b
\end{equation*}
%
funkcijski predpis s parametroma $a$ in $b$, ki elementu $x$ priredi element $a \cdot x + b$.

Spremenljivka $x$ nima v naprej določene vrednosti, pač pa kaže, kam lahko vstavimo
elemente domene. Pravimo, da je $x$ \df{vezana spremenljivka}, kar pomeni, da je veljavna
le v funkcijskem predpisu, nanj je vezana, in da ni pomembno, s katerim simbolom jo
označimo. Tako sta funkcijska predpisa
%
\begin{equation*}
  x \mapsto 1 + x^2
  \qquad\text{in}\qquad
  a \mapsto 1 + a^2
\end{equation*}
%
enaka in lahko bi celo pisali $\Box \mapsto 1 + \Box^2$ ali
$\heartsuit \mapsto 1 + \heartsuit^2$.

V funkcijskem predpisu mora na levi stati en sam simbol, ki na desni kaže, kam je treba
vstaviti element iz domene. Tako
%
\begin{equation*}
  \sin(x) \mapsto \cos(2 x),
  \qquad
  3 + 2 \mapsto 5
  \qquad\text{in}\qquad
  \sin(x) \mapsto 2 \cdot \sin(x)
\end{equation*}
%
\emph{niso} veljavni funkcijski predpisi.

Seveda dopuščamo možnost, da se vezana spremenljivka pojavi enkrat, večkrat ali sploh ne.
Funkcijska predpisa
%
%
\begin{equation*}
  x \mapsto 42
  \qquad\text{in}\qquad
  x \mapsto x \cdot \sin(x)
\end{equation*}
%
sta torej veljavna.

Če želimo preslikavo z danim funkcijskim predpisom poimenovati, na primer $f$, zapišemo
%
\begin{equation*}
  f : x \mapsto 1 + x^2.
\end{equation*}
%
To preberemo ``$f$ slika $x$ v ena plus $x$ na kvadrat.'' Običajna sta tudi zapisa
%
\begin{equation*}
  f(x) = 1 + x^2
  \qquad\text{in}\qquad
  f(x) \dfeq 1 + x^2.
\end{equation*}
%
Funkcijske predpise je podrobno prvi preučeval Alonzo Church,\footnote{Alonzo Church
  (1903--1995) je bil ameriški matematik in logik, ki je pomembno prispeval k razvoju
  logike in teoretičnega računalništva. Njegov študent, Dana Stewarta Scott, je imel
  študenta Marka Petkovška in Andreja Bauerja, slednji pa je imel študenta Davorina
  Lešnika.} ki je uporabljal zapis
%
\begin{equation*}
  \lambda x \,.\, 1 + x^2
\end{equation*}
%
in teorijo funkcijskih predpisov poimenoval \df{$\lambda$-račun}. V logiki se je njegov
zapis obdržal in se uveljavil tudi v programski jezikih:
%
\begin{itemize}
\item v Pythonu pišemo \verb|lambda x : 1+x**2|,
\item v Haskellu pišemo \verb|\x -> 1+x**2| in
\item v OCamlu pišemo \verb|fun x => 1+x*x|.
\end{itemize}
%
Predvsem v programiranju funkcijskim predpisom pravijo tudi \df{anonimne} ali \df{brezimne
  preslikave}.

Nekateri starejši zapisi funkcijskih predpisov so slabi, a jih ljudje vztrajno
uporabljajo. Opozorimo le na en slab zapis, ki povzroča precej preglavic, ne da bi se
matematiki tega zares zavedali. Funkcijski predpis mora določati vezano spremenljivko,
sicer ne vemo, kako vstaviti vrednosti, a na žalost jo matematiki pogosto izpustijo skupaj
z $\mapsto$, da ostane samo izraz na desni.
%
Težava je v tem, da se lahko v funkcijskem predpisu pojavi več kot en simbol. Če vam na primer povem, da imam v mislih funkcijski predpis
%
\begin{equation*}
  a \cdot x + b
\end{equation*}
%
boste vsi mislili, da je mišljeno $x \mapsto a \cdot x + b$. A pravzprav bi lahko bilo
tudi $a \mapsto a \cdot x + b$ ali $b \mapsto a \cdot x + b$ ali celo
$t \mapsto a \cdot x + b$! Namreč, nič ni narobe s funkcijskim predpisom, v katerem se
pojavijo dodatni simboli.

Morda pa lahko vezano spremenljivko in $\mapsto$ brez škode izpustimo, če v izrazu nastopa
samo en simbol, denimo $1 + x^2?$
%
A spet bi zabredli v težave. Je $42$ število ali funkcijski predpis $x \mapsto 42$? Je
$1 + x^2$ funkcijski predpis $x \mapsto 1 + x^2$ ali $a \mapsto 1 + x^2$?

Velikokrat površno rečemo, da funkcijski predpis podaja preslikavo. To ni res, saj smo že
prej povedali, da ima vsaka preslikava tri sestavne dele: domeno, kodomeno in prirejanje.
Res, če ne poznamo domene, ne moremo preveriti, ali je funkcijski predpis celovit. Denimo,
funkcijski predpis
%
\begin{equation*}
  x \mapsto \frac{x}{x^2 - 2}
\end{equation*}
%
ni celovit, če je domena množica realnih števil, in je celovit, če je domena množica
racionalnih števil. Tudi kodomeno moramo poznati, sicer ne moremo določiti nekaterih
lastnosti preslikave, kot je na primer surjektivnost, glej
razdelek~\ref{razdelek:injektivnost-in-surjektivnost}.



\subsection{Ostali načini podajanja preslikav}
\label{sec:ostali-predpisi}

Funkcijski predpisi niso edini način za podajanje prirejanja, zato omenimo še nekatere
druge.

Preslikavo s končno domeno lahko podamo s tabelo, na primer:
%
\begin{center}
  $f : \set{1, 2, 3, 5} \to \set{10, 20, 30}$

  \medskip

  \begin{tabular}{|c|c|} \hline
    1 & 10 \\ \hline
    2 & 10 \\ \hline
    3 & 20 \\ \hline
    5 & 10 \\ \hline
  \end{tabular}
\end{center}
%
To seveda pomeni, da $f$ elementu $1$ priredi $10$, $2$ priredi $10$, $3$ priredi $20$ in $5$
priredi $10$. Tabelo lahko predstavimo na različne načine, lahko kar naštejemo vsa prirejanja:
%
\begin{align*}
  f(1) &= 10 \\
  f(2) &= 10 \\
  f(3) &= 20 \\
  f(5) &= 10.
\end{align*}
%
Tudi
%
\begin{align*}
  1 &\mapsto 10 \\
  2 &\mapsto 10 \\
  3 &\mapsto 20 \\
  5 &\mapsto 10.
\end{align*}
%
je še vedno le tabela, ki prikazuje prirejanje. Ne sme nas motiti dejstvo, da smo
$\mapsto$ uporabili za naštevanje prirejanj, namesto za funkcijski prdpis.

Preslikava je lahko določena tudi z opisom računskega postopka, pravimo mu \df{algoritem},
s pomočjo katerega izračunamo vrednost preslikave pri danem argumentu. Paziti moramo, da je
opis postopka res natančen in nedvoumen, lahko ga kar zapišemo kot program. Teoretični
računalničar bi pripomnil, da je treba pri tem izbrati programski jezik, ki ima ustrezno
matematično definicijo.

Preslikave lahko podamo tudi tako, da opišemo pogoje, pri katerih je element kodomene
prirejen elementu domene. Na primer, preslikavo $f : \NN \to \ZZ$ bi lahko definirali z
zahtevo, da naravnemu številu $n \in \NN$ priredimo celo število $k \in \ZZ$, kadar velja
%
\begin{equation*}
  k^2 \leq n < (k+1)^2.
\end{equation*}
%
To prirejanje je veljavno, če je celovito in enolično, česar ne bomo preverjali, lahko pa
poskusite sami. Nekaj prirejanj $f$ prikazuje naslednja razpredelnica:
%
\begin{align*}
0 &\mapsto 0   &   4 &\mapsto 2   &    8  &\mapsto 2   &   12 &\mapsto 3 \\
1 &\mapsto 1   &   5 &\mapsto 2   &    9  &\mapsto 3   &   13 &\mapsto 3 \\
2 &\mapsto 1   &   6 &\mapsto 2   &    10 &\mapsto 3   &   14 &\mapsto 3 \\
3 &\mapsto 1   &   7 &\mapsto 2   &    11 &\mapsto 3   &   15 &\mapsto 3
\end{align*}
%
Ali znate z besedami opisati preslikavo~$f$?

V splošnem je lahko preslikava podana s precej zapleteno konstrukcijo, ki zahteva veliko
preverjanja in dokazovanja. Osnovne načine podajanja preslikav bomo spoznali skupaj s
konstrukcijami množic.


\subsection{Aplikacija in substitucija}
\label{sec:aplikacija-in-subsitucija}

Do sedaj smo se ukvarjali s tem, kako preslikavo podamo, zdaj pa se vprašajmo, kako lahko
preslikavo uporabimo. Če je $f : X \to Y$ preslikava iz $X$ v $Y$ in je $x \in X$, potem
lahko \df{$f$ uporabimo na $x$} in dobimo \df{vrednost} preslikave~$f$ pri
\df{argumentu}~$x$, to je tisti edini element $Y$, ki ga~$f$ priredi~$x$. Vrednost $f$
pri~$x$ zapišemo
%
\begin{equation*}
  f(x)
  \qquad\text{ali}\qquad
  f\,x
\end{equation*}
%
in preberemo ``$f$ od $x$'' ali ``$f$ pri $x$''. Izraz $f(x)$, oziroma $f\,x$, se imenuje
\df{aplikacija}. Večinoma se uporablja zapis z oklepaji, a ne vedno: navajeni smo pisati
$\ln 2$ in $\sin \alpha$ namesto $\ln(2)$ in $\sin(\alpha)$. Oklepaje izpuščamo tudi v
nekaterih programskih jezikih in občasno v algebri.

V analizi je uveljavljen še en zapis za aplikacijo, ki se uporablja za zaporedja. Namreč,
zaporedje ni nič drugega kot preslikava $a : \NN \to \RR$ iz naravnih v realna števila.
Aplikacijo $a(n)$, ki označuje $n$-ti člen zaporedja, ponavadi pišemo~$a_n$, torej
argument podpišemo.

Preslikavo lahko uporabimo na argumentu tudi, če je nismo poimenovali. Na primer,
preslikavo $\RR \to \RR$, podano s funkcijskim predpisom
%
\begin{equation*}
  x \mapsto 1 + x^2
\end{equation*}
%
uporabimo na argumentu~$3$:
%
\begin{equation*}
  (x \mapsto 1 + x^2)(3).
\end{equation*}
%
Se vam zdi tak zapis nenavaden? Verjetno, a pomislite, zakaj je tako: ker običajno
preslikave poimenujemo in se nanje vedno sklicujemo z njihovim imenom. Prav nobenega
razloga ni, da ne bi s funkcijskimi predpisi delali tako, kot s števili, vektorji in
ostalimi matematičnimi objekti, na katere smo že navajeni. Računalničarji radi rečejo, da
je treba tudi preslikave obravnavati kot ``enakopravne državljane''. Prav imajo, zato
bomo vadili uporabo funkcijskih predpisov ter z njimi delali, kot da niso nič posebnega,
saj niso!

Kako pravzaprav določimo vrednost funkcije pri danem argumentu? To je odvisno od tega,
kako je podano prirejanje. Če imamo tabelarični prikaz, poiščemo argument v levem stolpcu
in pogledamo v desni stolpec. Če je preslikava podana s funkcijskim predpisom, argument
vstavimo v predpis. Na primer, če je $f : \RR \to \RR$ podana s funkcijskim predpisom
%
\begin{equation*}
  f(x) = 1 + x^2,
\end{equation*}
%
potem je vrednost $f(3)$ enaka $1 + 3^2$, kar je seveda enako~$10$, a to zahteva dodaten
račun, ki nas v tem trenutku ne zanima. Pravimo, da smo simbol~$x$ \df{zamenjali} ali
\df{substituirali} s~$3$, oziroma da smo~$3$ \df{vstavili} v~$f$ namesto~$x$. Seveda lahko
vstavimo argument neposredno v funkcijski predpis, zato je aplikacija
%
\begin{equation*}
  (x \mapsto 1 + x^2)(3)
\end{equation*}
%
seveda spet enaka $1 + 3^2$.

Preslikavo smemo uporabiti na poljubnem elementu domene, ki je lahko zapisan na bolj ali
manj zapleten način, pri čemer gre še vedno samo za zamenjavo. Na primer, v zgornjo
preslikavo~$f$ lahko vstavimo $3 + 4$ in dobimo $1 + (3 + 4)^2$ ali pa za neki $u \in \RR$
vstavimo $u + 2$ in dobimo $1 + (u + 2)^2$. V razdelku~\ref{sec:eksponent} bomo spoznali
še dodatna pravila za vstavljanje izrazov, ki se vrtijo okoli vezanih spremenljivk.


\subsection{Načelo ekstenzionalnosti preslikav}

Kot smo že omenili, je možih več pogledov na preslikave. Ali je pomembno, kako učinkovito
računamo vrednosti preslikave? Vsekakor, ampak ali naj to pomeni, da sta preslikavi
različni, če imata enake vrednosti, a je ena podana z učinkovitim pravilom in druga z
neučinkovitim? V matematiki je odgovor nikalen.

\begin{pravilo}[Ekstenzionalnost preslikav]
  Preslikavi sta enaki, če imata enaki domeni in kodomeni ter imata za vse argumente
  enaki vrednosti.
\end{pravilo}

Natančneje, če sta $f : A \to B$ in $g : C \to D$ preslikavi in velja $A = C$, $B = D$ ter
za vsak $x \in A$ velja $f(x) = g(x)$, tedaj velja $f = g$.

Takoj opozorimo na razliko med
%
\begin{equation*}
  f(x) = g(x)
  \qquad\text{in}\qquad
  f = g
\end{equation*}
%
saj bi marsikdo trdil, da med njima ni razlike. Levi izraz pravi, da sta $f(x)$ in $g(x)$
enaka elementa množice $C$, desni pa da sta $f$ in~$g$ enaki preslikavi iz $A$ v $B$. Na
sploh je treba razlikovati med $f$ in $f(x)$, saj to nikakor nista enaka objekta: prvi je
preslikava, drugi pa vrednost te preslikave pri~$x$. Verjetno nihče ne bi trdil, da je
preslikava $\cos$ isto kot $\cos \frac{\pi}{4}$, ali ne? Isti razmislek veleva, da
$\cos x$ ni isto kot $\cos$, če tudi si mislimo, da je $x$ poljuben. Zmeda izhaja iz
neprimernega zapisa preslikav. Če bi že od malih nog pravilno uporabljali funkcijske
predpise, bi seveda vedeli, da načelo ekstenzionalnosti za preslikave zagotavlja enakost
~$\cos$ in $x \mapsto \cos x$, oba pa sta različna od $\cos x$, ki sploh ni preslikava,
ampak neko realno število. Čeprav je število $\cos x$ odvisno od parametra~$x$, je še
vedno le število.

V bran tradicionalnemu zapisu pa moramo vseeno povedati, da se lahko \emph{dogovorimo} za
nekoliko napačen zapis, če to ne povzroča zmede. S tem se izognemu preveč birokratskemu
pisanju nebistvenih podrobnosti in lahko bistveno izboljšamo komunikacijo in razumevanje
med izkušenimi matematiki. A začetnikom priporočamo, da v dobrobit boljšega razumevanja
snovi vsaj na začetku študija raje vztrajajo pri doslednem zapisu.

Vrnimo se še k načelu ekstenzionalnosti preslikav. Ali ni pravzaprav očitno, da sta
preslikavi enaki, če imata enaki domeni, kodomeni in vrednosti? Morda res, a to ni razlog,
da tega ne bi eksplicitno zapisali. Vsak matematik vam ve povedati kako zgodbo o tem,
kako se je v dokazu skrivala napako ravno tam, kjer je bilo nekaj ``očitno''. Poleg tega
pa si lahko predstavljamo razmere, v katerih je smiselno razlikovati med dvema
preslikavama, ki imata vedno enake vrednosti, denimo v programiranju, kjer je učinkovitost
zelo pomembna.

%% STAR MATERIAL OD DAVORINA. Preveriti, kaj od tega je treba dati v besedilo, in kam.

% Množice ne obstajajo ločene ena od druge pač pa so med sabo povezane s
% \df{preslikavami} oziroma s tujko \df{funkcijami}.  Posamična preslikava slika elemente ene
% množice po določenem predpisu v elemente druge množice.

% Če je $f$ preslikava, ki slika iz množice $X$ v množico $Y$, to zapišemo
% %
% \begin{equation*}
%   f : X \to Y.
% \end{equation*}
% %
% Rečemo, da je množica~$X$ \df{začetna množica} ali \df{domena} preslikave~$f$, množica~$Y$
% pa je \df{ciljna množica} ali \df{kodomena} preslikave $f$.


% Običaj je, da predpis preslikave podamo s pomočjo spremenljivke, tipično z oznako $x$. Na primer, če je $f$ preslikava kvadriranja, njen predpis zapišemo kot
% \[f(x) = x^2.\]
% Na tem mestu je potrebno poudariti več reči.
% \begin{itemize}
% \item
% Velikokrat površno rečemo, da zgornji predpis podaja preslikavo. To ni povsem res --- to je zgolj predpis preslikave. Za to, da preslikavo v celoti podamo, je potrebno navesti tri stvari: poleg predpisa še domeno in kodomeno. Vse to je del informacije o preslikavi.

% To se jasno pokaže, če začnemo razmišljati o lastnostih preslikav. Se še spomnite iz srednje šole, kaj pomeni, da je preslikava surjektivna? (Bomo ponovili v razdelku~\ref{razdelek:injektivnost-in-surjektivnost}.) Če vzamemo, da preslikava $f$ zadošča zgornjemu predpisu in jo obravnavamo kot preslikavo $f\colon \RR \to \RR$, ni surjektivna, če jo obravnavamo recimo kot preslikavo $f\colon \RR_{\geq 0} \to \RR_{\geq 0}$, pa je.
% \item
% Za spremenljivko $x$ velja isto, kot smo razpravljali že v prejšnjem razdelku pri lastnostih elementov množic: spremenljivka $x$ nima vnaprej določene vrednosti, pač pa predstavlja mesto, kamor lahko vstavimo poljubno vrednost. Seveda je potem vseeno, če vzamemo kakšno drugo črko ali čisto drug simbol: $f(y) = y^2$ določa isti predpis kot $f(x) = x^2$; prav tako $f(\heartsuit) = \heartsuit^2$. Se pravi, tudi v tem primeru gre za nemo spremenljivko. Če si torej izberemo neko vrednost, jo lahko vstavimo na mesto spremenljivke in izračunamo vrednost dobljenega izraza, npr.~$f(3) = 3^2 = 9$ oziroma $f(2\pi) = (2\pi)^2 = 4\pi^2$. Predstavljajte si, da je spremenljivka pravzaprav škatlica, kamor lahko vstavite vrednost, torej
% \[f(\argbox) = \argbox^2.\]
% \item
% Alternativen način zapisa $f(x) = x^2$ je
% \[f\colon x \mapsto x^2.\]
% Pazimo: navadna puščica $\to$ podaja domeno in kodomeno, kot razloženo zgoraj. Repata puščica $\mapsto$ pa za posamičen element domene pove, v kateri element kodomene se preslika.

% Zapis z repato puščico je še posebej uporaben, kadar želimo podati preslikavo, ne da bi nam bilo potrebno izbrati ime zanjo. Na primer, realno funkcijo kvadriranja lahko v celoti podamo takole:
% \begin{align*}
% \RR &\to \RR \\
% x &\mapsto x^2
% \end{align*}
% (prva vrstica pove domeno in kodomeno, druga pa predpis). Tako podanim preslikavam potem rečemo \df{brezimne preslikave} (s tujko \df{anonimne funkcije}). Kasneje (v razdelku~\ref{razdelek:brezimne-preslikave}) bomo spoznali bolj strnjen zapis takih preslikav, ki je še posebej primeren za izvajanje operacij med preslikavami; takrat bomo takšno funkcijo zapisali kot $\lam{x \in \RR} x^2$.
% \end{itemize}

% \note{Sklop (kompozicija, kompozitum) preslikav. Identiteta kot enota za sklapljanje. Razčlenitev (dekompozicija, faktorizacija) preslikav.}

% \davorin{Definirati moramo tudi oznako $\set{f(x)}{x \in X}$, kar je druge vrste oznaka kot prej definirana $\set{x \in X}{\phi(x)}$. Se gremo primerjavo s Pythonom (razlika med \texttt{\{f(x) for x in X\}} in \texttt{\{x if phi(x)\}})? Smo matematični hipsterji in uvedemo oznako $\{f(x) \,|\, x \in X \,|\, \phi(x)\}$, ki ustreza \texttt{\{f(x) for x in X if phi(x)\}}, kar bi tudi prišlo prav?}

% Zaenkrat smo imeli primere, ko je bil prepis preslikave dan z eno samo spremenljivko, npr.~$f(x) = x^2$. Zelo pogoste so pa tudi \df{preslikave več spremenljivk}, npr.~$f(x, y) = x^2 + y^2$. Že osnovne računske operacije so take --- na primer, pri seštevanju vzamemo \emph{dva} podatka in vrnemo rezultat (vsoto).

% V takem primeru je smiselno reči: domena preslikave sestoji iz \df{dvojic} ali \df{parov} števil. Pri seštevanju je to, katero število je prvo, katero pa drugo, sicer nepomembno, pri kakšni drugi operaciji (npr.~že odštevanju), pa je, zato posebej zahtevajmo: gre za \df{urejene dvojice} (\df{pare}). Urejeno dvojico elementov $a$ in $b$ (v tem vrstem redu) po dogovoru zapišemo kot $(a, b)$. Vrednosti $a$ in $b$ imenujemo \df{komponenti} tega para; natančneje, $a$ je \df{prva komponenta}, $b$ pa \df{druga komponenta}.

% Če imamo dve množici $A$ in $B$, tedaj množico vseh urejenih dvojic, katerih prva komponenta je element iz $A$, druga komponenta pa element iz $B$, označimo $A \times B$ in imenujemo \df{zmnožek} ali \df{produkt} množic $A$ in $B$. Glede na to, da obstaja mnogo operacij, ki se imenujejo ``produkt'' (poznate že vsaj produkt števil, produkt števila z vektorjem, skalarni produkt vektorjev in vektorski produkt vektorjev, obstaja pa jih še precej več), je koristno produkt množic posebej poimenovati, da ga ločimo od drugih: zanj se je uveljavil izraz \df{kartezični produkt} (izhaja iz imena Cartesius, tj.~latinske različice priimka Renéja Descarta\footnote{René Descartes (1596 -- 1650) je bil francoski filozof, matematik in znanstvenik.}).

% Seštevanje potemtakem lahko razumemo kot preslikavo $+\colon \RR \times \RR \to \RR$. V tem smislu še vedno gre za preslikavo, ki dan vhodni podatek preslika v neki rezultat, le da je vhodni podatek dvojica števil, ne pa zgolj eno število. Kadar imamo produkt več enakih faktorjev, ga lahko (kot običajno) zapišemo v obliki potence; pisali bi lahko tudi $+\colon \RR^2 \to \RR$.

% Seveda nismo omejeni na preslikave samo ene ali dveh spremenljivk. Nič nam ne preprečuje definirati recimo $f(x, y, z) = 2x + y - 3z$. Smiselna domena te preslikave setoji iz \df{urejenih trojic} števil. V splošnem, če jemljemo elemente iz množic $A$, $B$, $C$, tedaj se množica vseh takih trojic označi z $A \times B \times C$. Prejšnji predpis določa potem preslikavo $f\colon \RR \times \RR \times \RR \to \RR$ (oziroma krajše $f\colon \RR^3 \to \RR$).

% Spremenljivk je lahko še več; poleg dvojic in trojic tako dobimo še četverice, peterice, šesterice\ldots V splošnem takšna končna zaporedja elementov imenujemo \df{urejene večterice}. Tudi število spremenljivk je lahko označeno s črko; na primer, preslikava, ki računa povprečje $n$ števil (kjer $n \in \NN_{\geq 1}$), je dana kot
% \begin{align*}
% \RR^n &\to \RR \\
% (x_1, x_2, \ldots, x_n) &\mapsto \frac{x_1 + x_2 + \ldots + x_n}{n}
% \end{align*}
% (če hočemo poudariti, da imajo naše večterice natanko $n$ komponent, jih imenujemo $n$-terice). Nadlega pri tem je sicer spet dvoumnost tropičja. Deloma jo je možno odpraviti tako, da celotno večterico označimo z eno spremenljivko. Pogosta izbira zapisa je $f(\mathbf{x})$ ali $f(\vec{x})$ (razlog za to je, da lahko večterico vidimo kot vektor).

% Marsikdaj želimo delati ne samo z eno preslikavo, pač pa s celo množico preslikav naenkrat. Zato uvedemo: množica vseh preslikav, ki slikajo iz $X$ v $Y$, se označi kot $Y^X$; temu se reče \df{eksponent} množic $X$ in $Y$ (\note{na primernem mestu kasneje} bomo razložili, od kod ta oznaka).

% \begin{zgled}
% Množico vseh preslikav, ki realna števila slikajo nazaj v realna števila, označimo z $\RR^\RR$. Če nas zanimajo realne preslikave, ki so definirana samo na intervalu $\intoo{-1}{1}$, opazujemo množico $\RR^{\intoo{-1}{1}}$. Definiramo lahko preslikavo
% \begin{align*}
% \RR^{\intoo{-1}{1}} &\to \RR \\
% f &\mapsto f(0),
% \end{align*}
% ki preslikavam priredi njihovo vrednost v točki $0$. Ta preslikava torej ima za argumente (tj.~vnose) celotne preslikave in ne števila! Sama po sebi je element množice $\RR^{\RR^{\intoo{-1}{1}}}$.
% \end{zgled}

% \begin{zgled}
% Za poljubne množice $A$, $B$, $C$ lahko definiramo sledečo preslikavo, katere argumenti so pari preslikav.
% \begin{align*}
% B^A \times C^B &\to C^A \\
% (f, g) &\mapsto g \circ f
% \end{align*}
% \end{zgled}


% \davorin{Glede na to, da gre za slovenski učbenik, dajem izrazu `preslikava' prednost pred izrazom `funkcija'. Seveda pa sem pojasnil tudi slednji izraz (v prvem poglavju).}

% \note{Uvod. Definicijsko območje in zaloga vrednosti \davorin{morda dodamo kot možno ime za zalogo vrednosti še prevod angleške besede `range', se pravi `razpon'?}. Zožitve (tako domene kot kodomene); oznake za to so $\rstr{f}_A$, $\rstr{f}^B$, $\rstr{f}_A^B$. Izvrednotenje (evalvacija) preslikave (če ne bomo tega pojasnili že pri eksponentih množic).}


\section{Zmnožek}
\label{sec:zmnozek}

Množice lahko \df{tvorimo} ali \df{konstruiramo} iz drugih množic na različne načine. V
tem poglavju bomo spoznali tri osnovne konstrukcije, ostale pa kasneje, ko bomo že nekaj
vedeli o logiki. Najprej obravnavajmo zmnožek ali kartezični produkt.

Takoj se zastavi vprašanje, kako sploh opisati novo konstrukcijo množic. Načelo
ekstenzionalnosti pove, da je množica opredeljena s svojimi elementi. Torej moramo
pojasniti, kaj so elementi nove množice, se pravi, kako jih vpeljemo, kaj lahko z njimi
počnemo in kakšne so njihove zakonitosti. Natančneje, novo konstrukcijo množic
določajo naslednja pravila:
%
\begin{enumerate}
\item pravilo \df{tvorbe}, ki vpelje novo množico,
\item pravila \df{vpeljave} elementov, ki podajo operacije, s katerimi gradimo elemente,
\item pravila \df{uporabe}, ki podajo opreacije, s katerimi razgradimo ali uporabimo elemente,
\item \df{enačbe}, ki opredeljujejo zakonitosti, ki veljajo za operacije vpeljave in uporabe.
\end{enumerate}
%
Najbolje je, da si postopek ogledamo na primeru.

\begin{pravilo}[Tvorba zmnožka]
  \label{pravilo:zmnozek-tvorba}
  Za vsaki množici $A$ in $B$ je $A \times B$ množica, ki se imenuje \df{zmnožek} ali
  \df{kartezični produkt} $A$ in $B$.
\end{pravilo}

\noindent
%
Pravilo tvorbe pove, da lahko tvorimo novo množico $A \times B$, ne pove pa, kakšne
elemente ima. To je vsebina naslednjih dveh pravil, ki povesta, kako sestavimo in
razstavimo elemente zmnožka.

\begin{pravilo}[Vpeljava urejenih parov]
  \label{pravilo:zmnozek-vpeljava}
  %
  Za vse $a \in A$ in $b \in B$ je $(a, b) \in A \times B$. Element $(a, b)$ imenujemo
  \df{urejeni par}.
\end{pravilo}

\begin{pravilo}[Uporaba urejenih parov]
  \label{pravilo:zmnozek-uporaba}
    %
  Za vsak $p \in A \times B$ je $\fst(p) \in A$ \df{prva projekcija} in $\snd(p) \in B$
  \df{druga projekcija} elementa~$p$.
\end{pravilo}

Nazadnje podamo še enačbe.

\begin{pravilo}[Računsko pravilo za urejene pare]
  \label{pravilo:zmnozek-racunanje}
  Za vse $a \in A$, $b \in B$ velja $\fst(a, b) = a$ in $\snd(a, b) = b$.
\end{pravilo}

\begin{pravilo}[Ekstenzionalnost urejenih parov]
  \label{pravilo:zmnozek-ekstenzionalnost}
  Za vse $p, q \in A \times B$ velja: če $\fst(p) = \fst(q)$ in $\snd(p) = \snd(q)$,
  potem $p = q$.
\end{pravilo}

\noindent
%
Računsko pravilo se tako imenuje, ker lahko z njim poenostavljamo izraze, drugo pa je
načelo ekstenzionalnosti, ker pravi, da je urejeni par določen s prvo in drugo projekcijo.

Malo bolj naivna konstrukcija zmnožka bi se glasila takole: kartezični produkt
$A \times B$ je množica vseh urejenih parov $(a, b)$, kjer je $a \in A$ in $b \in B$. A
taka konstrukcija ni popolna, saj ne pove, kaj lahko z urejenim parom počnemo. Kako naj
vemo, da iz $(a, b)$ lahko izluščimo $a$ in $b$, in kako preverimo, ali sta dva urejena
para enaka? Če takih zadev ne določimo, bi lahko kdo mislil, da je urejeni par kaka druga
operacija, denimo seštevanje, unija, ali kdovekaj.

Dejstvo, da je vsak element zmnožka množic urejen par, in to celo na en sam način, lahko
dokažemo.

\begin{trditev}
  Naj bosta $A$ in $B$ množici. Za vsak element $p \in A \times B$ obstaja natanko en
  $a \in A$ in natanko en $b \in B$, da velja $p = (a, b)$.
\end{trditev}

\begin{proof}
  Naj bosta $A$ in $B$ množici in $p \in A \times B$. Najprej pokažimo, da $p$ res je enak
  nekemu urejenemu paru, namreč
  %
  \begin{equation*}
    p = (\fst(p), \snd(p)).
  \end{equation*}
  %
  Uporabimo načelo ekstenzionalnosti za pare, ki nam zagotavlja to enačbo, če dokažemo
  %
  \begin{equation*}
    \fst(p) = \fst(\fst(p), \snd(p))
    \qquad\text{in}\qquad
    \snd(p) = \snd(\fst(p), \snd(p)).
  \end{equation*}
  %
  Ti dve enačbi pa veljata, ker sta primerka računskih pravil za pare.

  Preveriti moramo še, da je $(\fst(p), \snd(p))$ edini urejeni par, ki je enak~$p$.
  Povedano z drugimi besedami, dokazati moramo: če je $p = (a, b)$ za neki $a \in A$ in
  $b \in B$, potem velja $a = \fst(p)$ in $b = \snd(p)$. Pa denimo, da bi za neki
  $a \in A$ in $B \in B$ veljalo $p = (a,b)$. Tedaj bi lahko uporabili računska pravila za
  pare in dobili
  %
  \begin{equation*}
    \fst(p) = \fst(a, b) = a
    \qquad\text{in}\qquad
    \snd(p) = \snd(a, b) = b,
  \end{equation*}
  %
  kar smo želeli dokazati.
\end{proof}

Trditev je prikladna, ko želimo podati funkcijsko pravilo za preslikavo, katere domena je
zmnožek množic. Primer take preslikave je
%
\begin{gather*}
  \RR \times \RR \to \RR \\
  p \mapsto \fst(p) + \snd(p)^2 \cdot \fst(p).
\end{gather*}
%
Ta zapis je precej nepregleden, a sledili smo navodilu, da mora stati na levi strani
funkcijskega predpisa simbol. Prejšnja trditev nam zagotavlja, da lahko vsak element
$\RR \times \RR$ na en sam način izrazimo kot urejeni par $(x, y)$, in zato ne bo nič
narobe, če zapišemo ta isti funkcijski predpis bolj pregledno tako, da upoštevamo, da
je $p$ enak $(x, y)$ za enolično določena $x$ in $y$:
%
\begin{gather*}
  \RR \times \RR \to \RR \\
  (x, y) \mapsto x + y^2 \cdot x.
\end{gather*}
%
Če bi funkcijo poimenovali, denimo $f$, bi dobili običajni zapis:
%
\begin{gather*}
  f : \RR \times \RR \to \RR \\
  f(x, y) = x + y^2 \cdot x.
\end{gather*}
%
Za tako preslikavo pravimo, da je ``funkcija dveh spremenljivk'', ker si mislimo, da smo
podali argumenta $x$ in $y$ ločeno drug od drugega. Tu pravzaprav vidimo, da bi lahko
rekli tudi, da je funkcija dveh spremenljivk pravzaprav običajna funkcija, katere
arugmenti so urejeni pari.

Poleg zmnožka dveh množic bi lahko tvorili tudi zmnožek treh ali več množic. Pravila bodo
podobna kot za zmnožek dveh množic, le da bi namesto urejenih parov tvorili \df{urejene
  večterice} in da bi imeli več projekcij. Za vsako projekcijo bi zapisali eno računsko
pravilo, princip ekstenzionalnosti pa bi bil tudi podoben tistemu za urejene pare.
Podorobnosti prepustimo za vajo.


\section{Vsota}
\label{sec:vsota}

Spoznali smo že unijo $A \cup B$ množic $A$ in $B$, ki vsebuje tiste elemente, ki so v $A$
ali v $B$. Če imata $A$ in $B$ skupne elemente, bodo ti v uniji seveda nastopili samo
enkrat. V skranjem primeru dobimo $A \cup A = A$. Včasih pa želimo združiti množici tako,
da ne pride do prekrivanja. Taka konstrukcija je \df{vsota} $A + B$ množic $A$ in $B$.
Prekrivanje preprečimo tako, da elemente, ki jih je prispevala~$A$ označimo z eno oznako,
tiste, ki jih je prispevala~$B$, pa z drugo.

\begin{pravilo}[Vsota]
  \label{vsota:tvorba}
  Za vsaki množici $A$ in $B$ je $A + B$ množica, ki se imenuje \df{vsota} ali
  \df{koprodukt} množic $A$ in $B$.
\end{pravilo}

\begin{pravilo}[Vpeljava elementov vsote]
  \label{vsota:vpeljava}
  Za vsaki množici $A$ in $B$ velja:
  %
  \begin{enumerate}
  \item za vsak $a \in A$ je $\inl(a) \in A + B$,
  \item za vsak $b \in B$ je $\inr(b) \in A + B$.
  \end{enumerate}
\end{pravilo}

S pravilom vpeljave smo pojasnili, da uporabljamo oznaki $\inl$ in $\inr$, prvo za
elemente iz~$A$ in drugo za elemente iz~$B$. Oznakama pravimo tudi
\df{injekciji}\footnote{Pravzaprav niti ni pomembno, kako poimenujemo oznaki, da sta le
  različni. V funkcijskem programiranju, kjer poznamo vsote podatkovnih tipov, programer
  sam določi, kakšne oznake bo uporabljal za injekcije.} in sta preslikavi
%
\begin{equation*}
  \iota_1 : A \to A + B
  \qquad\text{and}\qquad
  \iota_2 : N \to A + B.
\end{equation*}
%
Kadar imamo opravka z večimi vsotami, na primer $A + B$ in $C + D$, bi lahko prišlo do
zmede glede oznak. Takrat injekcije opremimo še z dodatnimi oznakami množic, da razločimo
injekciji $\inl[A][B] : A \to A + B$ in $\inl[C][D] : C \to C + D$, in podobno za~$\inr$.

Potrebujemo še pravili za uporabo in enakost elementov vsote, ki ju združimo v eno samo
pravilo.

\begin{pravilo}
  \label{vsota:uporaba}
  Za vsaki množici $A$ in $B$ in za vsak $u \in A + B$, bodisi obstaja natanko en
  $a \in A$, da je $u = \inl(a)$, bodisi obstaja natanko en $b \in B$, da je
  $u = \inr(b)$.
\end{pravilo}

Fraza ``bodisi \dots bodisi'' pomeni, da je vsak element $u \in A + B$ enak $\inl(a)$
za natanko en $a \in A$ ali $\inr(b)$ za natanko en $b \in B$, ne more pa se zgoditi oboje
hkrati ali nič od tega. Torej $\inl(a) = \inr(b)$ ne drži in celo v primeru, ko je
$A = B$ in $a = b$, je $\inl(a) \neq \inr(b)$. S tem smo v $A + B$ res ločili elemente $A$
od elementov $B$.
%
Fraza ``natanko en'' pove, da iz $u = \inl(a_1)$ in $u = \inl(a_2)$ sledi $a_1 = a_2$.
Povedano drugače, če velja $\inl(a_1) = \inl(a_2)$, potem je $a_1 = a_2$. Podobno iz
$\inr(b_1) = \inr(b_2)$ sledi $b_1 = b_2$.
%
Podajmo prepost primer, ki verjetno marsikaj pojasni:
%
\begin{equation*}
  \set{a, b, c} + \set{a, d, e} =
  \set{\inl(a), \inl(b), \inl(c), \inr(a), \inr(d), \inr(e)}.
\end{equation*}

Kako definiramo preslikavo $A + B \to C$? Ker je vsak element domene $A + B$ bodisi
$\inl(a)$ za neki $a \in A$ bodisi $\inr(b)$ za neki $b \in B$, \emph{obravnavamo oba
  primera}. Tako funkcijski zapis za preslikavo $A + B \to C$ zapišemo kot
%
\begin{equation*}
  u \mapsto
  \begin{cases}
    \cdots a \cdots & \text{če $u = \inl(a)$,}\\
    \cdots b \cdots & \text{če $u = \inr(b)$,}
  \end{cases}
\end{equation*}
%
kjer smemo v $\cdots a \cdots$ zapisati izraz, ki vsebuje simbol~$a$, in v
$\cdots b \cdots$ izraz, ki vsebuje simbol~$b$. Ker je tak zapis nekoliko neroden, se
dogovorimo, da ga lahko zapišemo tudi s \emph{večdelnim} funkcijskim predpisom:
%
\begin{align*}
  \inl(a) &\mapsto \cdots a \cdots, \\
  \inr(b) &\mapsto \cdots b \cdots.
\end{align*}
%
Če želimo preslikavo poimenovati, zapišemo
%
\begin{align*}
  f &: A + B \to C, \\
  f(\inl(a)) &= \cdots a \cdots \\
  f(\inr(b)) &= \cdots b \cdots.
\end{align*}
%
Vsi ti zapisi res določajo celovito in enolično prirejanje, saj nam pravila za vsoto
zagotavljajo, da vedno obvelja natanko en primer. Na sploh lahko podamo funkcijski zapis z
večimi primeri, če le pazimo, da obravnavamo vse možnosti, in da se le-te ne prekrivajo.
Na primer, predpis
%
\begin{align*}
  (A + B) \times C &\to B + A \\
  (\inl[A][B](a), c) &\mapsto \inr[B][A](a) \\
  (\inr[A][B](b), c) &\mapsto \inl[B][A](b)
\end{align*}
%
je celovit in enoličen, medtem ko predpis
%
\begin{align*}
  (A \times A) + B &\to A \\
  \inl(a_1, a_2) &\mapsto a_2
\end{align*}
%
ni veljaven, ker ni celovit, saj manjka primer $\inr(b) \mapsto \cdots$.

Poleg vsote dveh množic bi lahko tvorili zmnožek treh ali več množic. Pravila bi bila
podobna, le da bi imeli več injekcij in več primerov.

% \section{Eksponent}
% \label{sec:eksponent}



% Zapis funkcijskega predpisa na razne načine.
% \note{Tj.~anonimne oz.~čiste funkcije. Na tem mestu pride tudi $\lambda$-notacija in določena mera $\lambda$-računa.}

% Aplikacija kot operacija.

% Eksponent kot množica vseh preslikav. Pravila za eksponent: kako naredimo elemente
% eksponenta in kako jih uporabimo. Enačbe ($\beta$ in ekstenzionalnost).

% Vezane spremenljivke v zapisu funkcijskega predpisa. Substitucija in vezane spremenljivke.

% Preslikave iz prazne množice in v prazno množice. Preslikave iz enojca in v enojec.


% Transponiranje (currying).


% \section{Izomorfizmi med množicami}
% \label{sec:izom-med-mnoic}

% \davorin{Andrej, o inverzih sem že nekaj pisal v razdelku o bijekcijah (razdelek~\ref{razdelek:bijektivnost-in-obratne-preslikave}) --- poglej, če ti bo kaj prišlo prav.}

% Definicija inverza in izomorfizma. \davorin{inverz = obrat}

% \davorin{Hm\ldots Pa poskusimo\ldots\\ izomorfizem = istoličje,\\ morfizem = ličje.\\ Dobesedno prevedeno je homomorfizem = enakoličje, ampak to ni najboljši prevod v tem kontekstu. Predlagam\\ homomorfizem = naličje,\\ ker `naličen' (med drugim) pomeni `podoben', `soroden'.}

% Če je preslikava izomorfizem, je tudi njen inverz.

% Izomorfnost množic. Je refleksivna, simetrična in tranzitivna (a ne poudarjamo preveč pojma ekvivalence na tem mestu).

% Izomorfnost je kongruenca za produkt, vsoto in eksponent.

% \section{Aritmetika Tarskega}
% \label{sec:aritmetika-tarskega}

% Aritmetični zakoni Tarskega za množice. Podobnost z običajno aritmetiko.

% Pri asociativnosti produkta obravnavamo $A_1 \times A_2 \times \cdots \times A_n$ in
% enojec kot produkt nič množic. Podobno za vsote.

% Tu je treba pojasniti, zakaj pišemo $\unit$ za element $\one$.


% \section{Kar je že Davorin napisal}

% Interval realnih števil podamo s krajiščema intervala v oklepajih --- okrogli oklepaji ( ) označujejo odprtost intervala (krajišče ni vključeno v interval), oglati oklepaji [ ] pa zaprtost (krajišče je vključeno). Tako se npr.~interval realnih števil od $0$ do $1$, ki ne vsebuje krajišč, označi z $(0, 1)$, če jih vsebuje, pa z $[0, 1]$.

% Včasih pridejo prav tudi intervali na drugih množicah kot $\RR$. Zato se dogovorimo, da bomo intervale označevali tako, da podamo množico, ob kateri v indeksu zapišemo krajišči v oklepajih, npr.~$\intco[\NN]{1}{5} = \set{1, 2, 3, 4}$. Realna intervala iz prejšnjega odstavka tako zapišemo kot $\intoo{0}{1}$ in $\intcc{0}{1}$.

% Če interval v katero smer gre v nedogled, preprosto zapišemo množico z ustreznim simbolom za urejenost in krajiščem v indeksu. Na primer, $\RR_{> 0}$ označuje množico pozitivnih realnih števil, $\RR_{\geq 0}$ pa množico nenegativnih realnih števil.

% Primerjave med elementi, kot npr.~pravkar podani $>$ in $\geq$, imenujemo \df{relacije} (podrobneje jih bomo spoznali v poglavju~\ref{poglavje:relacije}). Zgornji zapis bomo uporabljali tudi za druge vrste relacij, ne samo za relacije urejenosti. Na primer, množico vseh neničelnih realnih števil zapišemo kot $\RR_{\neq 0}$.

% \davorin{To bi vsaj bil moj predlog. Na ta način se izognemo dvoumnostim (kar je namen). Na primer, kaj pomeni $\forall\, a > 0$? Če zapišemo $\forall\, a \in \NN_{> 0}$ ali $\forall\, a \in \RR_{> 0}$, je jasno. Razlog, da matematiki ``goljufajo'' in pridejo skozi brez tega, je (napol dogovorjena in ponotranjena, ampak arbitrarna) izbira črk; vsak izkušen matematik ve, da $\forall\, \epsilon > 0$ pomeni $\forall\, \epsilon \in \RR_{> 0}$. Dodaten problem je, da kasneje uporabljamo urejene pare, ki jih vsi na naši fakulteti pišejo z okroglimi oklepaji. Poskusimo se izogniti zmedi, ali $(a, b)$ pomeni urejeni par ali odprti interval. Če se ne strinjate, popravite in pustite komentar.}

% Če imamo dan neki element in neko množico, potem pripadnost tega elementa tej množici izrazimo s simbolom $\in$. Na primer, da je štiri naravno število, zapišemo $4 \in \NN$ (beri: ``štiri pripada množici naravnih števil'').

% Elementi množic lahko zadoščajo raznim lastnostim. Na primer, recimo, da $\phi$ označuje lastnost ``biti manj od pet''; to potem zapišemo
% \[\phi(x) \ = \ \ x < 5.\]
% V tem primeru $x$ imenujemo \df{spremenljivka}, saj ne gre za točno določeno vrednost, pač pa predstavlja splošno število (recimo, da se dogovorimo, da s $\phi$ označujemo lastnost na realnih številih).

% Tovrstne lastnosti nam omogočajo, da iz neke množice odberemo elemente z dano lastnostjo in na ta način dobimo novo množico, ki je podmnožica prejšnje. Množico vseh realnih števil, ki so manjša od pet, zapišemo na naslednji način.
% \[\set{x \in \RR}{x < 5}\]
% Seveda, ker je primerjava s števili zelo pogosta lastnost, je uporabno, če uvedemo krajše oznake, ki povejo isto; že prej smo se dogovorili, da tako množico označimo z $\RR_{< 5}$. Za povsem splošne lastnosti pa ne bomo imeli vnaprej dogovorjenih oznak, zato je dobro, da poznamo splošni zapis. Torej, če je $X$ poljubna množica in $\phi$ poljubna lastnost njenih elementov, tedaj podmnožico, ki vsebuje točno tiste elemente množice $X$, ki zadoščajo lastnosti $\phi$, označimo takole.
% \[\set[1]{x \in X}{\phi(x)}\]

% Pri tem se zavedajmo: ni pomembno, da spremenljivko označimo ravno z $x$. Zapis
% \[\set[1]{y \in X}{\phi(y)}\]
% še vedno označuje isto množico. V vsakem primeru gre za množico vseh elementov iz $X$ z lastnostjo $\phi$. Pravzaprav sploh ni nujno, da uporabimo črko; poslužimo se lahko kateregakoli simbola (ki mu nismo predtem že predpisali določenega pomena). Taisto množico lahko zapišemo tudi $\set{\heartsuit \in X}{\phi(\heartsuit)}$.

% Kadar imamo spremenljivko, ki jo lahko preimenujemo, ne da bi spremenili pomen izraza, jo imenujemo \df{nema spremenljivka}. Takšne primere že dobro poznate; na primer, integral $\int_0^1 x^2 \,dx$ se ne spremeni, če preimenujete spremenljivko in zapišete $\int_0^1 y^2 \,dy$.

% \begin{zgled}
% Kako bi zapisali množico vseh sodih naravnih števil? Spomnimo se, da je število sodo, kadar je deljivo z $2$. Za $n \in \NN$ to zapišemo takole: $2 \divides n$ (beri: ``dve deli $n$''). Množica sodih naravnih števil se potem zapiše kot
% \[\set[1]{n \in \NN}{2 \divides n}.\]
% \end{zgled}


\section{Vaje}

\begin{vaja}
  Kaj veste povedati o množici $A$, če zanjo velja, da so vsi njeni elementi enaki?
\end{vaja}

\begin{vaja}
  Načelo ekstenzionalnosti preslikav bi lahko zapisali tudi takole:
  %
  \begin{quote}
    Preslikavi $f : A \to B$ in $g : C \to D$ sta enaki, če velja $A = C$, $B = D$ in za
    vse $x_1, x_2 \in A$ velja, da iz $x_1 = x_2$ sledi $f(x_1) = g(x_2)$.
  \end{quote}
  %
  Dokažite, da je ta različica enakovredna običajnem načelu ekstenzionalnosti.
\end{vaja}

\begin{vaja}
  Zapišite pravila za zmnožek treh množic. Nato premislite še, kako bi podali pravila za
  zmnožek $n$ množic, kjer je~$n$ naravno število.
\end{vaja}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "ucbenik-lmn"
%%% End:
