\chapter{Številske množice}

Številske množice (naravna števila, cela števila, \ldots) poznate že od nekdaj. O njih imate zadosti občutka oz.~intuitivne predstave, da jih lahko uporabljate in pridete do pravilnih rezultatov. Tudi v tej knjigi smo jih že kar naprej izkoriščali za razne primere.

Ampak intuitivna predstava je tudi vse, kar zaenkrat imamo o številskih množicah. Nismo še podali natančne matematične definicije zanje, na osnovi katere bi lahko neizpodbitno dokazovali izreke o njih.

Za vajo lahko sami premislite, ali bi znali na tem mestu podati natančno definicijo, kaj pomeni biti naravno, celo, racionalno oz.~realno število. Definicija seveda mora biti natančna --- npr.~reči, da so realna števila tista, ki ležijo na številski premici, ni zadovoljiva definicija (vsaj ne, če ne pojasnite nedvoumno, kaj pomeni ``številska premica'' in kaj pomeni ``ležati'' na njej).

V tem poglavju se bomo sistematično lotili obravnave najpogosteje uporabljanih številskih množic. Podali bomo njihove konstrukcije, karakterizacije in temeljne lastnosti.


\section{Naravna števila}

\subsection{Peanovi aksiomi}

Če vas kdo vpraša, kako dobiti vsa naravna števila, verjetno odgovorite nekaj v naslednjem smislu: naravna števila so $0$ in vsa tista števila, ki jih dobite s prištevanjem enice, tj.~jemanjem naslednika. Torej, začnemo z $0$, vzamemo naslednika in dobimo $1$, nato še enkrat vzamemo naslednika in dobimo $2$ itd.

Prvi, ki je znal to intuitivno predstavo preliti v natančno matematično definicijo, je bil Peano\footnote{Giuseppe Peano (1858 -- 1932) je bil italijanski matematik.} komaj dobro stoletje nazaj. Pogoje, ki jih zahtevamo za neko množico, da jo lahko imenujemo ``množica naravnih števil'', po njem imenujemo \df{Peanovi aksiomi}. \davorin{Nekje bomo predebatirali, kaj je aksiom in zakaj jih uporabljamo. Peanove aksiome povežimo s tem.}

Če boste brskali po literaturi, boste naleteli na mnogo različnih inačic Peanovih aksiomov. Mi bomo izbrali sledečo jedrnato različico.

\begin{definicija}[Peano]\label{definicija:naravna-stevila}
\df{Množica naravnih števil} je množica (običajno označena z $\NN$), skupaj z izbranim njenim elementom (običajno označenim z $0$, kar beremo ``ničla'' ali ``nič'') in preslikavo na tej množici (običajno označeno z $\suc\colon \NN \to \NN$, ki jo imenujemo ``naslednik''), kadar veljajo naslednje lastnosti:
\begin{itemize}
\item
$\suc$ je injektivna preslikava,
\item
$0 \notin \rn{\suc}$,
\item
velja načelo \df{matematične indukcije}: če je $\phi$ predikat na $\NN$, za katerega velja
\[\phi(0) \qquad\qquad \text{in} \qquad\qquad \all{n \in \NN} (\phi(n) \implies \phi\big(\suc(n)\big)),\]
tedaj $\phi$ velja za vse elemente $\NN$.
\end{itemize}
\end{definicija}

Poskusimo si zdaj natančno pojasniti pomen teh pogojev.

S pomočjo elementa $0$ in preslikave $\suc$ lahko v nedogled generiramo elemente množice $\NN$. Začnemo z $0$, nato vzamemo naslednika in dobimo $\suc(0)$, nato vzamemo naslednika tega elementa in dobimo $\suc(\suc(0))$, nato naslednika $\suc(\suc(\suc(0)))$ itd. Takšen zapis je sicer precej nepraktičen --- si predstavljate, da rečete ``dobimo se čez naslednika od naslednika od naslednika od naslednika od naslednika ničle ur'' (namesto ``dobimo se čez pet ur'')? Zato sprejmemo dogovor: $\suc(0)$ označimo krajše z $1$ in preberemo ``ena'', $\suc(\suc(0))$ označimo z $2$ in preberemo ``dve'' in tako naprej.\footnote{Trenutno dogovorjena sistematična imena za števila gredo do \df{centiljona}, ki ga zapišemo z enico, ki ji sledi 600 ničel (vsaj pri nas; ponekod po svetu centiljon pomeni enica s 303 ničlami). To pomeni, da lahko sistematično izrazimo števila do $10^{606}-1$ (= devetsto devetindevetdeset centiljard devetsto devetindevetdeset centiljonov devetsto devetindevetdeset novemnonagintiljard\ldots). Nekateri razširijo to lestvico še z nadaljnjimi latinskimi izpeljankami, obstajajo pa tudi posebna imena za nekatera posamična velika števila, na primer \df{gugol} za $10^{100}$ (od tod izhaja ime spletnega brskalnika Google).}

Smo na ta način dobili neskončno različnih elementov $\NN$? Če ne bi zahtevali zgornjih pogojev, to ne bi bilo nujno. Lahko bi se namreč zaciklali (v smislu, da je naslednik nekega elementa element, ki smo ga že prej navedli).

Včasih je takšno zaciklanje nekaj, kar dejansko hočemo. Na primer, pri algebri boste spoznali tako imenovane \df{ciklične grupe}. Ciklično grupo z $n$ elementi označimo $\ZZ_n$, njene elemente pa kar z $0, 1, \ldots, n-1$. Spodaj je slika ciklične grupe $\ZZ_5$.

\note{slika usmerjenega grafa, ki predstavlja $\ZZ_5$}

Puščice označujejo, kako slika naslednik v tej grupi: naslednik $0$ je $1$, naslednik $1$ je $2$, naslednik $2$ je $3$, naslednik $3$ je $4$, nato pa se zacikla in naslednik $4$ je $0$.

Pogoj $0 \notin \rn{\suc}$ reče, da nič ni naslednik nobenega naravnega števila. Na ta način se izognemo, da bi naravna števila tvorila ciklično grupo.

Obstaja pa še en način, kako se lahko jemanje naslednika zacikla. Vzemimo spodnji primer.

\note{slike polgrupe $\set{0, \ldots, 4}$, ki se zacikla $4 \to 2$}

Nasledniki se lahko zaciklajo tudi pri elementu, ki ni $0$. V danem primeru je naslednik $0$ element $1$, naslednik $1$ je $2$, naslednik $2$ je $3$, naslednik $3$ je $4$, naslednik $4$ pa je $2$.

Zakaj naravna števila niso taka? Ker v danem primeru $\suc$ ni injektivna preslikava. Pogoj o injektivnosti nam v bistvu pove sledeče: naravna števila se ne morejo zaciklati pri nobenem nasledniku.

Vidimo, da se naravna števila ne morejo zaciklati niti na začetku (pri $0$) niti nekje vmes v verigi naslednikov --- torej gredo v nedogled, kot želimo. Z drugimi besedami, $0$, $\suc(0)$, $\suc(\suc(0))$, $\suc(\suc(\suc(0)))$,\ldots so medsebojno različni elementi množice $\NN$ in naravnih števil je posledično neskončno.

Čemu pa služi zadnji pogoj iz definicije~\ref{definicija:naravna-stevila}, tj.~načelo o indukciji? Že brez tega pogoja vemo, da so $0$, $\suc(0)$, $\suc(\suc(0))$, $\suc(\suc(\suc(0)))$,\ldots naravna števila, česar pa ne vemo, je, da so to \emph{vsa} naravna števila --- da torej ni nobenih drugih.

\begin{vaja}
Premisli, da množica $\RR_{> -1}$ z naslednikom $\suc(x) \dfeq x+1$ zadošča vsem pogojem iz definicije~\ref{definicija:naravna-stevila}, razen načelu indukcije.
\end{vaja}

Vidimo, da bi brez načela indukcije lahko imeli v množici $\NN$ odvečna števila (takšna, ki jih ne štejemo kot naravna). S predpostavko o indukciji se to ne more zgoditi. Ta namreč pravi: če neka lastnost velja za začetni element verige $0$, $\suc(0)$, $\suc(\suc(0))$, $\suc(\suc(\suc(0)))$,\ldots in če lahko sklepamo, da kakor hitro ta lastnost velja za določen element verige, velja tudi za naslednjega, potem ta lastnost velja za vsa naravna števila. Če za lastnost vzamemo ``biti element te verige'', iz načela o indukciji sklenemo, da se vsako naravno število nahaja nekje v tej verigi. Peanovi aksiomi torej podajajo strukturo, ki ustreza naši intuitivni predstavi množice naravnih števil.

Glede na to, da je načelo o matematični indukciji eden od osnovnih aksiomov, s katerimi so naravna števila podana, ne preseneča, da je indukcija eden najpogostejših načinov, kako dokazujemo izjave na naravnih številih. Natančneje rečeno, z matematično indukcijo dokazujemo univerzalno kvantificirane izjave na naravnih številih, torej izjave oblike
\[xall{n \in \NN} \phi(n).\]
Po načelu indukcije za dokaz take izjave zadostuje narediti naslednje. Najprej dokažemo
\[\phi(0)\]
(da torej lastnost $\phi$ velja za začetno naravno število). To imenujemo \df{temelj} ali \df{osnova} ali \df{baza} indukcije. Nato dokažemo izjavo
\[\all{n \in \NN} \phi(n) \implies \phi(\suc(n));\]
to imenujemo \df{indukcijski korak}. Z besedami, dokažemo, da kakor hitro velja lastnost $\phi$ za neko naravno število, mora veljati ta lastnost tudi za naslednje.

Intuitivno je jasno, da to mora delovati. Temelj indukcije nam pove, da dana lastnost velja za $0$. Ker zdaj vemo, da velja za $0$, mora po indukcijskem koraku veljati za naslednika ničle, torej za $1$. Zdaj vemo, da velja za $1$, torej mora po indukcijskem koraku veljati tudi za $2$. Tako nadaljujemo: sklepamo, da lastnost velja za $3$, nato za $4$ in tako naprej. Ker se vsa naravna števila pojavijo v verigi naslednikov ničle, mora z indukcijo dokazana lastnost dejansko veljati za vsa naravna števila.

V poglavju~\ref{poglavje:indukcija} se bomo vrnili k indukciji, jo natančneje preučili in si ogledali primere dokazovanja z njo. Na tem mestu pa jo bomo uporabili za izpeljavo \emph{rekurzije}, ki nam bo služila za definicijo nadaljnje strukture na naravnih številih.

\subsection{Rekurzija}

Poenostavljeno povedano, rekurzija pomeni, da določimo vrednost preslikave pri nekem argumentu iz (že prej naračunanih) vrednosti pri manjših argumentih. Tipičen primer rekurzivno podane preslikave je faktoriela: če zapišemo $0! \dfeq 1$ in $n! \dfeq (n+1) \cdot n!$ za vse $n \in \NN$, smo s tem enolično podali preslikavo $!\colon \NN \to \NN$.

Naračunajmo nekaj vrednosti te preslikave. Neposredno iz definicije dobimo $0! = 1$ --- to je \df{temelj} oz.~\df{osnova} oz.~\df{baza} rekurzije. Od tod s pomočjo \df{rekurzijskega koraka} izpeljemo
\[1! = 1 \cdot 0! = 1 \cdot 1 = 1.\]
S pomočjo te vrednosti in z rekurzijskim korakom lahko naračunamo vrednost faktoriele pri naslednjem naravnem številu.
\[2! = 2 \cdot 1! = 2 \cdot 1 = 2\]
In tako naprej.
\[3! = 3 \cdot 2! = 3 \cdot 2 = 6\]
\[4! = 4 \cdot 3! = 4 \cdot 6 = 24\]
\[5! = 5 \cdot 4! = 5 \cdot 24 = 120\]
\[\vdots\]
Vidimo, da lahko po tem postopku prej ali slej naračunamo $n!$ za poljuben $n \in \NN$.

V primeru faktoriele smo neko vrednost naračunali iz predhodne, uporabljajo se pa tudi splošnejše rekurzivne definicije, kjer vrednost naračunamo iz večih prejšnjih. Slovit primer je \df{Fibonaccijevo zaporedje} $F\colon \NN \to \NN$, podano kot $F_0 \dfeq 0$, $F_1 \dfeq 1$ in $F_{n+2} \dfeq F_{n+1} + F_n$ za vse $n \in \NN$. Od tod lahko naračunamo:
\begin{align*}
F_0 &= 0, \\
F_1 &= 1, \\
F_2 &= F_1 + F_0 = 1 + 0 = 1, \\
F_3 &= F_2 + F_1 = 1 + 1 = 2, \\
F_4 &= F_3 + F_2 = 2 + 1 = 3, \\
F_5 &= F_4 + F_3 = 3 + 2 = 5, \\
F_6 &= F_5 + F_4 = 5 + 3 = 8, \\
&\vdots
\end{align*}
Bo pa za naše potrebe zaenkrat zadostovala oblika rekurzije, kjer se skličemo samo na en predhodni člen, in na tako se bomo v tej knjigi tudi omejili. \davorin{Lahko pa vseeno v kakšni vaji zahtevamo od študentov, da zapišejo in dokažejo splošnejše načelo rekurzije.}

Zakaj bi pa sploh podajali preslikave rekurzivno namesto z izrecnim (eksplicitnim) predpisom? Včasih to sledi iz narave problema. Na primer, imamo stanje, ki se razvija korak za korakom, kjer je trenutno stanje odvisno od prejšnjega. Zanima nas, kako se naš sistem razvija, in v tem primeru je naravno podati trenutno stanje sistema kot rekurzivno preslikavo. \note{ponazorimo s primerom}

Včasih preslikavo podamo rekurzivno, ker je rekurzivni predpis mnogo enostavnejši kot izrecni. Na primer, izrecna predpisa za faktorielo in Fibonaccijevo zaporedje sta
\[n! = \int_0^\infty x^n e^{-x} \; dx\]
in
\[F_n = \frac{\Big(\frac{1+\sqrt{5}}{2}\Big)^n - \Big(\frac{1-\sqrt{5}}{2}\Big)^n}{\sqrt{5}}.\]
Odvisno od tega, katera vrednost vas zanima, utegneta biti ta dva predpisa mnogo bolj okorna za računanje, kot pa rekurzivna. Pravzaprav nekaj časa traja, da sploh dokažete, da so rezultati teh predpisov naravna števila!

Včasih pa preslikavo podamo rekurzivno preprosto zato, ker nimamo druge možnosti. Zgornja predpisa sicer podajata preslikavi izrecno, ampak cena za to je uporaba zapletenih operacij na realnih številih, kot so integral, eksponentna funkcija z naravno osnovo in korenjenje. Strogo vzeto smo zaenkrat od številskih množic definirali samo naravna števila, pa še zanje znamo povedati zgolj, kaj je $0$ in kaj je naslednik. V bistvu še ne ``znamo'' niti seštevati!

S pomočjo rekurzije bomo lahko definirali ostalo strukturo, ki jo poznamo na naravnih številih: seštevanje, množenje in tako naprej. Za začetek pa natančno izoblikujmo in dokažimo načelo o rekurziji na naravnih številih. Iz zgornje razprave je jasno, da je rekurzija tesno povezana z indukcijo, od koder jo bomo tudi izpeljali.

\begin{izrek}[Načelo rekurzije]\label{izrek:rekurzija}
Imejmo poljubni množici $X$ in $Y$ ter preslikavi $b\colon X \to Y$ in $r\colon X \times Y \times \NN \to Y$. Tedaj obstaja natanko ena preslikava $f\colon X \times \NN \to Y$, za katero velja
\[f(x, 0) = b(x)\]
in
\[f\big(x, \suc(n)\big) = r\big(x, f(n, x), n\big)\]
za vse $x \in X$ in $n \in \NN$.

Temu natančneje rečemo \df{načelo parametrizirane rekurzije}, ker pri preslikavi $f$ na naravnih številih dopuščamo še poljuben parameter iz množice $X$. Če za $X$ vzamemo enojec, se zgornja izjava reducira na sledeče \df{načelo neparametrizirane rekurzije}.

Če imamo množico $Y$, element $b \in Y$ in preslikavo $r\colon Y \times \NN \to Y$, tedaj obstaja natanko ena preslikava $f\colon \NN \to Y$, za katero velja
\[f(0) = b\]
in
\[f\big(\suc(n)\big) = r\big(f(n), n\big)\]
za vse $n \in \NN$.
\end{izrek}

\begin{dokaz}
\end{dokaz}

Rekurzijo smo na ta način izpeljali iz indukcije, poudarimo pa, da je možen tudi obraten pristop: načelo o rekurziji vzamemo kot osnoven aksiom naravnih števil \emph{namesto} indukcije, nato pa od tod izpeljemo načelo o indukciji. Poglejmo, kako to storimo.

Vzemimo poljuben predikat $\phi\colon \NN \to \tvs$, za katerega velja $\phi(0)$ in $\all{n \in \NN} (\phi(n) \implies \phi(\suc(n)))$. Po načelu rekurzije obstaja natanko ena preslikava $f\colon \NN \to \tvs$, za katero velja $f(0) = \true$ in $f\big(\suc(n)\big) = f(n) \lor \phi\big(\suc(n)\big)$ za vse $n \in \NN$. Ampak predikat $\phi$ sam zadošča tema pogojema, saj lahko izjavo $\phi(n) \implies \phi\big(\suc(n)\big)$ enakovredno zapišemo kot $\phi\big(\suc(n)\big) = \phi(n) \lor \phi\big(\suc(n)\big)$. Očitno pa tudi povsod resničen predikat zadošča danima pogojema, od koder zaključimo $\phi = \lam{n \in \NN}{\true}$.

V tem smislu sta načeli rekurzije in indukcije enakovredni. Kot vidimo, lahko pravzaprav na indukcijo gledamo kot na poseben primer rekurzije, konkretno za preslikave oblike $\NN \to \tvs$. To nam pove, da je ta primer tako generičen, da je iz njega možno dobiti načelo za poljubne preslikave oblike $X \times \NN \to Y$.

\note{Rekurzor kot preslikava. Morda pripomba, ki zgornjo diskusijo poveže s primitivno rekurzijo iz teorije izračunljivosti.}

\subsection{Računske operacije}

Uporabimo zdaj izpeljano rekurzijo za natančno matematično definicijo strukture na naravnih številih, ki jo neformalno poznate že od malih nog. Začnimo z osnovnimi računskimi operacijami.

Seštevanje želimo definirati kot preslikavo $\NN \times \NN \to \NN$. Da ga definiramo rekurzivno, moramo povedati, kaj pomeni prišteti ničlo in kaj pomeni prišteti naslednika nekega števila (izraženo z vsoto, ki jo dobimo iz prištetja tega števila samega). Smiselno je podati naslednje.
\begin{align*}
m + 0 &\dfeq m \\
m + \suc(n) &\dfeq \suc(m + n)
\end{align*}
V tej definiciji $m$ nastopa kot parameter --- se pravi, uporabili bomo načelo parametrizirane rekurzije. Glede na oznake iz izreka~\ref{izrek:rekurzija} smo vzeli $X = \NN$, $Y = \NN$, $b(m) = m$ (torej je $b$ identiteta na $\NN$) in $r(m, v, n) = \suc(v)$ (se pravi, $r$ je kompozicija projekcije na drugo komponento in preslikave naslednika). Po tem izreku dobimo enolično določeno preslikavo $+\colon \NN \times \NN \to \NN$ (ki igra vlogo preslikave $f$ iz izreka).

Dokažimo, da pravkar definirano seštevanje zadošča zakonom, na katere smo navajeni. Začnimo s tem, da preverimo, da je $0$ enota za seštevanje.

Seveda velja $a + 0 = a$ za vse $a \in \NN$ --- to je del definicije seštevanja. Od tod pa ne smemo takoj sklepati na $0 + a = a$, saj še nismo dokazali izmenljivosti seštevanja. Lahko bi na tem mestu začeli z dokazom izmenljivosti, ampak kot bomo videli, bomo za to že potrebovali dejstvo, da je $0$ enota. Dokažimo torej $0 + a = a$ za vse $a \in \NN$ neposredno.

Trditev dokazujemo z indukcijo. Najprej dokažemo trditev za $a = 0$, torej $0 + 0 = 0$. To je res po definiciji.

Privzemimo, da velja $0 + a = a$ za neki $a \in \NN$. Dokazujemo $0 + \suc(a) = \suc(a)$. Preverimo:
\[0 + \suc(a) = \suc(0 + a) = \suc(a).\]

Kaj pa, če namesto $0$ prištejemo $1$? Takrat seveda pričakujemo, da dobimo naslednika. Preverimo.

Za poljuben $a \in \NN$ dobimo $a + 1 = a + \suc(0) = \suc(a + 0) = \suc(a)$. Tukaj sploh nismo potrebovali indukcije. Jo pa potrebujemo za dokaz, da za vsak $a \in \NN$ velja $1 + a = \suc(a)$. Za $a = 0$ je to definicija oznake $1$. Recimo, da za neki $a \in \NN$ velja $1 + a = \suc(a)$. Tedaj $1 + \suc(a) = \suc(1 + a) = \suc(\suc(a))$.

Prepričajmo se zdaj o družilnosti (asociativnosti) seštevanja. Dokazati želimo izjavo
\[\all{a \in \NN}\all{b \in \NN}\all{c \in \NN}{(a + b) + c = a + (b + c)}.\]
Vzemimo poljubna $a, b \in \NN$, notranjo univerzalno kvantificirano izjavo pa dokažimo z indukcijo (po spremenljivki $c$). Če vzamemo $c = 0$, izjava velja: $(a + b) + 0 = a + b = a + (b + 0)$. Privzemimo zdaj, da pri nekem $c \in \NN$ velja $(a + b) + c = a + (b + c)$. Poračunamo
\[(a + b) + \suc(c) = \suc\big((a + b) + c\big) = \suc\big(a + (b + c)\big) = a + \suc(b + c) = a + \big(b + \suc(c)\big).\]

Zdaj lahko dokažemo izmenljivost (komutativnost) seštevanja. Dokazati želimo izjavo
\[\all{a \in \NN}\all{b \in \NN}{a + b = b + a}.\]
Vzemimo poljuben $a \in \NN$, nato pa nadaljujmo z indukcijo (po $b$). Za $b = 0$ trdimo $a + 0 = 0 + a$. To smo že dokazali --- obe strani enakosti sta enaki $a$, saj vemo, da je $0$ enota za seštevanje.

Predpostavimo zdaj, da velja $a + b = b + a$ za neki $b \in \NN$. Izpeljati želimo $a + \suc(b) = \suc(b) + a$. Preverimo:
\[a + \suc(b) = \suc(a + b) = \suc(b + a) = 1 + (b + a) = (1 + b) + a = \suc(b) + a.\]

Na podoben način lahko definiramo množenje in dokažemo njegove lastnosti. Smiselna rekurzivna definicija množenja je sledeča.
\begin{align*}
m \cdot 0 &\dfeq 0 \\
m \cdot \suc(n) &\dfeq m \cdot n + m
\end{align*}
Če primerjamo z izrekom~\ref{izrek:rekurzija}, smo vzeli $X = Y = \NN$, $b(m) = 0$ (torej je $b$ konstantna ničelna preslikava) in $r(m, v, n) = v + m$ (to preslikavo lahko definiramo s pomočjo pravkar definiranega seštevanja). Izrek nam porodi enolično določeno preslikavo $\cdot\colon \NN \times \NN \to \NN$.

Podobno kot prej pri seštevanju za začetek ugotovimo, kaj se zgodi, ko množimo z $0$ oziroma $1$. Po definiciji vemo $a \cdot 0 = 0$ za vse $a \in \NN$. Dokažimo še $0 \cdot a = 0$ za vse $a \in \NN$. Za $a = 0$ velja $0 \cdot 0 = 0$ po definiciji. Vzemimo, da velja $0 \cdot a = 0$ za neki $a \in \NN$. Tedaj $0 \cdot \suc(a) = 0 \cdot a + 0 = 0 + 0 = 0$.

Število $1$ bi morala biti enota za množenje. Preverimo. Najprej $a \cdot 1 = a \cdot s(0) = a \cdot 0 + a = 0 + a = a$. Po drugi strani trditev, da za vse $a \in \NN$ velja $1 \cdot a = a$, dokažemo z indukcijo. Enakost $1 \cdot 0 = 0$ je jasna. Recimo, da trditev velja za neki $a \in \NN$. Tedaj $1 \cdot \suc(a) = 1 \cdot a + 1 = a + 1 = \suc(a)$.

Preden se lotimo družilnosti in izmenljivosti množenja, dokažimo, da je množenje razčlenitveno (distributivno) čez seštevanje. Se pravi, dokazati želimo izjavi
\[\all{a \in \NN}\all{b \in \NN}\all{c \in \NN}{(a + b) \cdot c = a \cdot c  + b \cdot c}\]
in
\[\all{a \in \NN}\all{b \in \NN}\all{c \in \NN}{a \cdot (b + c) = a \cdot b + a \cdot c}.\]
Pri prvi od izjav (desni razčlenitvi) vzemimo poljubna $a, b \in \NN$, nato pa se lotimo indukcije po $c$. Dobimo $(a + b) \cdot 0 = 0 = 0 + 0 = a \cdot 0 + b \cdot 0$. Če velja $(a + b) \cdot c = a \cdot c  + b \cdot c$ za neki $c$, tedaj
\[(a + b) \cdot \suc(c) = (a + b) \cdot c + (a + b) = a \cdot c + b \cdot c + a + b = a \cdot c + a + b \cdot c + b = a \cdot \suc(c) + b \cdot \suc(c).\]
Pri drugi izjavi (levi razčlenitvi) sklepamo podobno: $a \cdot (b + 0) = a \cdot b = a \cdot b + 0 = a \cdot b + a \cdot 0$. Nato privzamemo izjavo za neki $c$ in poračunamo
\[a \cdot \big(b + \suc(c)\big) = a \cdot \suc(b + c) = a \cdot (b + c) + a = a \cdot b + a \cdot c + a = a \cdot b + a \cdot \suc(c).\]

Preverimo zdaj družilnost množenja, torej izjavo
\[\all{a \in \NN}\all{b \in \NN}\all{c \in \NN}{(a \cdot b) \cdot c = a \cdot (b \cdot c)}.\]
Vzemimo poljubna $a, b \in \NN$ in se lotimo indukcije po $c$. Za $c = 0$ dobimo $(a \cdot b) \cdot 0 = 0 = a \cdot 0 = a \cdot (b \cdot 0)$. Predpostavimo izjavo za neki $c$ in poračunamo
\[(a \cdot b) \cdot \suc(c) = (a \cdot b) \cdot c + a \cdot b = a \cdot (b \cdot c) + a \cdot b = a \cdot (b \cdot c + b) = a \cdot \big(b \cdot \suc(c)\big).\]

Naposled preverimo še izmenljivost množenja na naravnih številih, torej izjavo
\[\all{a \in \NN}\all{b \in \NN}{a \cdot b = b \cdot a}.\]
Vzemimo poljuben $a \in \NN$. Za $b = 0$ dobimo $a \cdot 0 = 0 = 0 \cdot a$. Vzemimo, da izjava velja za neki $b$. Tedaj
\[a \cdot \suc(b) = a \cdot b + a = b \cdot a + a = b \cdot a + 1 \cdot a = (b + 1) \cdot a = \suc(b) \cdot a.\]

Na kratko lahko to celotno razpravo povzamemo: množica naravnih števil $\NN$ tvori izmenljiv polkolobar z enico. \davorin{ta pojem bo pojasnjen že v prejšnjem poglavju o strukturah} Seveda pa ne tvori kolobarja; vemo, da naravnih števil ne moremo poljubno odštevati. Še vedno pa lahko odštevanje na naravnih številih podamo kot \emph{delno} operacijo, torej kot delno preslikavo $-\colon \NN \times \NN \parto \NN$. Spomnimo se namreč \note{od polkolobarjev v prejšnjem poglavju}, da je odštevanje delna preslikava natanko tedaj, ko je polkolobar krajšalen.

Dokažimo krajšalnost polkolobarja naravnih števil, torej izjavo
\[\all{a \in \NN}\all{b \in \NN}\all{x \in \NN}\big(a + x = b + x \implies a = b\big).\]
Vzemimo poljubna $a, b \in \NN$, nato pa se kot običajno poslužimo indukcije. Pri $x = 0$ smo takoj na koncu. Privzemimo izjavo $a + x = b + x \implies a = b$ za neki $x$ in naj velja $a + \suc(x) = b + \suc(x)$. Tedaj $\suc(a + x) = \suc(b + x)$ in ker je $\suc$ injektivna preslikava (eden od Peanovih aksiomov!), sklepamo $a + x = b + x$, od tod pa $a = b$.\footnote{Injektivnost preslikave $\suc$ je točno to, kar potrebujemo za krajšalnost. Velja namreč tudi obrat: če imamo $\suc(a) = \suc(b)$, tj.~$a + 1 = b + 1$, in lahko krajšamo, potem $a = b$.}

S pomočjo (delnega) odštevanja lahko definiramo \df{predhodnika} na naravnih številih, in sicer kot $\prd(n) \dfeq n - 1$. Tudi to je zgolj delna preslikava $\prd\colon \NN \parto \NN$; ničla je edino naravno število, ki ni v njenem definicijskem območju.

\begin{vaja}
Dokaži $\all{n \in \NN}{\prd\big(\suc(n)\big) \kleq n}$.
\end{vaja}

Včasih je pa uporabno imeti obliko predhodnika in odštevanja, ki sta celoviti preslikavi. Pri predhodniku se dogovorimo, da se pomaknemo za eno nazaj, če se le da (pri ničli torej ostanemo, kjer smo). To različico predhodnika lahko definiramo z rekurzijo na naslednji način.
\begin{align*}
\tilde{\prd}(0) &\dfeq 0 \\
\tilde{\prd}\big(\suc(n)\big) &\dfeq n
\end{align*}
Po načelu o neparametrizirani rekurziji dobimo enolično določeno preslikavo $\tilde{\prd}\colon \NN \to \NN$ (konkretno, v izreku~\ref{izrek:rekurzija} vzamemo $Y = \NN$, $b = 0$ in $r(v, n) = n$).\footnote{Morda se vam zdi vprašljivo, če bi to definicijo sploh imenovali ``rekurzivna'', saj $\tilde{\prd}\big(\suc(n)\big)$ nismo izrazili s $\tilde{\prd}(n)$ (ali z drugimi besedami, preslikava $r$ ni odvisna od svojega prvega argumenta). Ampak izrek~\ref{izrek:rekurzija} za ta primer še vedno velja in zgornja definicija torej podaja dobro definirano preslikavo $\tilde{\prd}\colon \NN \to \NN$.}

Od tod lahko definiramo tako imenovano \df{prisekano odštevanje} na naravnih številih. Simbol za to operacijo je $\monus$, kar se prebere ``monus'' (torej: $1 + 2$ se bere ``ena plus dve'', $1 - 2$ se bere ``ena minus dve'' in $1 \monus 2$ se bere ``ena monus dve'').

Ideja prisekanega odštevanja je, da zmanjševanec zmanjšamo za tolikšen del odštevanca, kolikor le lahko (tako da še ostanemo v okviru naravnih števil). Z drugimi besedami: če se običajno odštevanje izide v naravnih številih, velja $a \monus b = a - b$, sicer pa velja $a \monus b = 0$. Natančna rekurzivna definicija je sledeča.
\begin{align*}
m \monus 0 &\dfeq m \\
m \monus \suc(n) &\dfeq \tilde{\prd}(m \monus n)
\end{align*}
Se pravi, če v izreku~\ref{izrek:rekurzija} vzamemo $X = Y = \NN$, $b(m) = m$ in $r(m, v, n) = \tilde{\prd}(v)$, dobimo preslikavo $\monus\colon \NN \times \NN \to \NN$.

\davorin{Ko se dokončno dogovorimo, kako bomo prevajali precendenco in asociiranje, povejmo, da ima prisekano odštevanje isto precendenco kot navadno odštevanje in da se asociira z leve.}

Oglejmo si nekaj lastnosti, ki veljajo za prisekano odštevanje. Po definiciji je $0$ desna enota, ni pa leva enota, kot takoj sledi iz naslednje vaje (od tod je jasno tudi, da $\monus$ ni izmenljiv).

\begin{vaja}
Dokaži $\all{n \in \NN}{0 \monus n = 0}$.
\end{vaja}

Bolj zvito je preveriti, da za vse $n \in \NN$ velja $n \monus n = 0$. Če poskusimo to neposredno dokazati z indukcijo, bomo hitro naleteli na oviro. Namesto tega se raje lotimo splošnejše trditve: dokažimo
\[\all{n \in \NN}\all{a \in \NN}{(n + a) \monus n = a}.\]
Dokažimo trditev za $n = 0$. Vzemimo poljuben $a \in \NN$ in poračunajmo $(0 + a) \monus 0 = a \monus 0 = 0$. Predpostavimo zdaj, da velja trditev $\all{a \in \NN}{(n + a) \monus n = a}$ za neki $n$. Dokazati želimo $\all{a \in \NN}{\big(\suc(n) + a\big) \monus \suc(n) = a}$. Vzemimo poljuben $a \in \NN$. Tedaj
\[\big(\suc(n) + a\big) \monus \suc(n) = \big(n + 1 + a\big) \monus \suc(n) = \big(n + \suc(a)\big) \monus \suc(n) =\]
\[= \tilde{\prd}\Big(\big(n + \suc(a)\big) \monus n\Big) = \tilde{\prd}\big(\suc(a)\big) = a.\]
Razmisli natančno, zakaj velja predzadnji enačaj! Če zamenjamo univerzalna kvantifikatorja v začetni izjavi, da dobimo $\all{a \in \NN}\all{n \in \NN}{(n + a) \monus n = a}$, in uporabimo trditev za $a = 0$, sklenemo naposled $n \monus n = 0$ za vse $n \in \NN$.

Prisekano odštevanje seveda ni družilno (nič bolj kot navadno odštevanje). Kot nadomestek pa nam služi naslednja trditev:
\[\all{a \in \NN}\all{b \in \NN}\all{c \in \NN}{(a \monus b) \monus c = a \monus (b + c)}.\]
Dokažimo jo. Vzemimo poljubna $a, b \in \NN$ in se lotimo indukcije po $c$. Pri $c = 0$ dobimo $(a \monus b) \monus 0 = a \monus b = a \monus (b + 0)$. Privzemimo zdaj enakost pri nekem $c$ in jo preverimo pri nasledniku:
\[(a \monus b) \monus \suc(c) = \tilde{\prd}\big((a \monus b) \monus c\big) = \tilde{\prd}\big(a \monus (b + c)\big) = a \monus \suc(b + c) = a \monus \big(b + \suc(c)\big).\]

Preden dokažemo še členjenje množenja čez prisekanego odštevanje, si pripravimo pomožno trditev.

\begin{lema}
Velja sledeče.
\begin{enumerate}
\item
Vsako naravno število je bodisi nič bodisi naslednik; se pravi, velja trditev
\[\all{n \in \NN}{n = 0 \xor \some{m \in \NN}{n = \suc(m)}}.\]
Lahko smo še natančnejši: če je število naslednik, je naslednik svojega predhodnika. Trdimo torej
\[\all{n \in \NN}{n = 0 \xor n = \suc\big(\tilde{\prd}(n)\big)}.\]
\item
Velja
\[\all{a \in \NN}\all{b \in \NN}{a \cdot \tilde{\prd}(b) = a \cdot b \monus a}.\]
\end{enumerate}
\end{lema}

\begin{dokaz}
\begin{enumerate}
\item
Po Peanovih aksiomih velja $0 \notin \rn{\suc}$, torej naravno število ne more biti hkrati nič in naslednik. Zadostuje potemtakem, da dokažemo samo še $\all{n \in \NN}{n = 0 \lor n = \suc\big(\tilde{\prd}(n)\big)}$.

Preverimo z indukcijo. Trditev očitno velja za $n = 0$. Recimo, da velja za neki $n$, in se lotimo dokazovanja za $\suc(n)$. Pri dokazovanju disjunkcije si izberimo, da dokazujemo drugi disjunkt. Z računom smo takoj konec: $\suc\Big(\tilde{\prd}\big(\suc(n)\big)\Big) = \suc(n)$ (uporabili smo družilnost sklapljanja preslikav in rekurzivno definicijo celovitega predhodnika).
\item
Vzemimo poljubna $a, b \in \NN$. Po prejšnji točki velja bodisi $b = 0$ bodisi $b = \suc\big(\tilde{\prd}(b)\big)$. V prvem primeru dobimo
\[a \cdot \tilde{\prd}(0) = a \cdot 0 = 0 = 0 \monus a = a \cdot 0 \monus a.\]
Predpostavimo, da smo v drugem primeru, da torej velja $b = \suc\big(\tilde{\prd}(b)\big)$. Račun bo bolj očiten, če začnemo z druge strani:
\[a \cdot b \monus a = a \cdot \suc\big(\tilde{\prd}(b)\big) \monus b = \big(a \cdot \tilde{\prd}(b) + a\big) \monus a = a \cdot \tilde{\prd}(b).\]
\end{enumerate}
\end{dokaz}

Zdaj smo naposled pripravljeni, da dokažemo členjenje množenja čez prisekano odštevanje v naravnih številih. Ker že vemo, da je množenje izmenljivo, zadostuje preveriti členjenje samo na eni strani. Dokažimo torej $\all{a \in \NN}\all{b \in \NN}\all{c \in \NN}{a \cdot (b \monus c) = a \cdot b \monus a \cdot c}$.

Vzemimo poljubna $a, b \in \NN$ in nadaljujmo z indukcijo po $c$. Pri $c = 0$ takoj dobimo $a \cdot (b \monus 0) = a \cdot b = a \cdot b \monus 0 = a \cdot b \monus a \cdot 0$. Recimo zdaj, da trditev velja za neki $c$. Dokažimo jo za $\suc(c)$:
\[a \cdot \big(b \monus \suc(c)\big) = a \cdot \tilde{\prd}(b \monus c) = a \cdot (b \monus c) \monus a = (a \cdot b \monus a \cdot c) \monus a = a \cdot b \monus (a \cdot c + a) = a \cdot b \monus a \cdot \suc(c).\]

\note{Ena od vaj: rekurzivna definicija in dokaz lastnosti potenciranja}

\subsection{Urejenost}
\subsection{Nadaljnje karakterizacije}


\section{Cela števila}
\section{Racionalna števila}
\section{Realna števila}
\section{Kompleksna števila}

\davorin{Se ustavimo že pri realnih številih? Gremo še dlje do kvaternionov?}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "ucbenik-lmn"
%%% End:
